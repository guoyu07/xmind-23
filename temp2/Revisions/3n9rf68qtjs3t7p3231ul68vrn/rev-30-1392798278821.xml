<?xml version="1.0" encoding="UTF-8" standalone="no"?><xmap-revision-content xmlns="urn:xmind:xmap:xmlns:revision:1.0" xmlns:fo="http://www.w3.org/1999/XSL/Format" xmlns:svg="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" xmlns:xlink="http://www.w3.org/1999/xlink"><sheet id="3n9rf68qtjs3t7p3231ul68vrn" timestamp="1392798175939" xmlns="urn:xmind:xmap:xmlns:content:2.0"><topic id="2mj3lbgfs17g99mh8gtg989d9u" structure-class="org.xmind.ui.map.clockwise" timestamp="1392781092735"><title>SpringMVC</title><notes><html><xhtml:p>   <xhtml:img xhtml:src="xap:attachments/6j0f59a2ns8v76a9p39nk29v3k.JPG"/></xhtml:p></html><plain>   </plain></notes><children><topics type="attached"><topic id="1qe8nbsjd99md2ni42aqh4ago2" timestamp="1392787412345"><title>1 controller</title><children><topics type="attached"><topic id="53s8k2b1hmchgevucumi5hc57h" timestamp="1392791746066"><title>1.1 Controller接口方式</title><children><topics type="attached"><topic id="1344k4krvtp0n55j1042al9gua" timestamp="1392776827971"><title>1.1.1 利用标准接口org.springframework.web.servlet.mvc.Controller</title><notes><html><xhtml:p>bean的name即未映射路径</xhtml:p><xhtml:p/><xhtml:p>&lt;!-- 处理器 --&gt;  </xhtml:p><xhtml:p>&lt;bean name="/hello" class="cn.javass.chapter2.web.controller.HelloWorldController"/&gt;  </xhtml:p></html><plain>bean的name即未映射路径

&lt;!-- 处理器 --&gt;  
&lt;bean name="/hello" class="cn.javass.chapter2.web.controller.HelloWorldController"/&gt;  </plain></notes></topic><topic id="499a1v95l49vl22lfeblskratq" timestamp="1392776831874"><title>1.1.2 使用AbstractController支持缓存，requestSession等</title><notes><html><xhtml:p>org.springframework.web.servlet.mvc.AbstractController</xhtml:p></html><plain>org.springframework.web.servlet.mvc.AbstractController</plain></notes></topic><topic id="10e2u3bu23vol95lc4rklssji4" timestamp="1392777685531"><title>1.1.2数据类型转换</title><children><topics type="attached"><topic id="7taqbtmp1cv20ml4pt8i1csjmi" timestamp="1392777129671"><title>1spring内建数据类型转换器</title><notes><html><xhtml:p><xhtml:img xhtml:src="xap:attachments/5q5a490sp244mqs9u63haf2ech.png"/></xhtml:p></html><plain/></notes></topic><topic id="41mpqf2q7o93mruae07kt6e2p1" timestamp="1392778160839"><title>2使用自定义的属性编辑器</title><children><topics type="attached"><topic id="7la7k6d41o73ksja02sbjmu41s" timestamp="1392777326211"><title>1创建数据模型</title><notes><html><xhtml:p>//省略import  </xhtml:p><xhtml:p>public class DataBinderTestModel {  </xhtml:p><xhtml:p>    private String username;  </xhtml:p><xhtml:p>    private boolean bool;//Boolean值测试  </xhtml:p><xhtml:p>    private SchoolInfoModel schooInfo;  </xhtml:p><xhtml:p>    private List hobbyList;//集合测试，此处可以改为数组/Set进行测试  </xhtml:p><xhtml:p>    private Map map;//Map测试  </xhtml:p><xhtml:p>    private PhoneNumberModel phoneNumber;//String-&gt;自定义对象的转换测试  </xhtml:p><xhtml:p>    private Date date;//日期类型测试  </xhtml:p><xhtml:p>    private UserState state;//String——&gt;Enum类型转换测试  </xhtml:p><xhtml:p>    //省略getter/setter  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p>  </xhtml:p><xhtml:p>package cn.javass.chapter4.model;  </xhtml:p><xhtml:p>//如格式010-12345678  </xhtml:p><xhtml:p>public class PhoneNumberModel {  </xhtml:p><xhtml:p>    private String areaCode;//区号  </xhtml:p><xhtml:p>    private String phoneNumber;//电话号码  </xhtml:p><xhtml:p>    //省略getter/setter  </xhtml:p><xhtml:p>}  </xhtml:p></html><plain>//省略import  
public class DataBinderTestModel {  
    private String username;  
    private boolean bool;//Boolean值测试  
    private SchoolInfoModel schooInfo;  
    private List hobbyList;//集合测试，此处可以改为数组/Set进行测试  
    private Map map;//Map测试  
    private PhoneNumberModel phoneNumber;//String-&gt;自定义对象的转换测试  
    private Date date;//日期类型测试  
    private UserState state;//String——&gt;Enum类型转换测试  
    //省略getter/setter  
}  
  
package cn.javass.chapter4.model;  
//如格式010-12345678  
public class PhoneNumberModel {  
    private String areaCode;//区号  
    private String phoneNumber;//电话号码  
    //省略getter/setter  
}  </plain></notes></topic><topic id="4ja5ps9qt96du22su38lf29u5b" timestamp="1392777356067"><title>2创建数据模型属性编辑器，实现PropertyEditor接口或继承PropertyEditorSupport</title><notes><html><xhtml:p>PropertyEditorSupport：一个PropertyEditor的支持类；</xhtml:p><xhtml:p>setAsText：表示将String——&gt;PhoneNumberModel，根据正则表达式进行转换，如果转换失败抛出异常，则接下来的验证器会进行验证处理；</xhtml:p><xhtml:p>getAsText：表示将PhoneNumberModel——&gt;String。</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>public class PhoneNumberEditor extends PropertyEditorSupport {  </xhtml:p><xhtml:p>    Pattern pattern = Pattern.compile("^(\\d{3,4})-(\\d{7,8})$");  </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    public void setAsText(String text) throws IllegalArgumentException {  </xhtml:p><xhtml:p>        if(text == null || !StringUtils.hasLength(text)) {  </xhtml:p><xhtml:p>            setValue(null); //如果没值，设值为null  </xhtml:p><xhtml:p>        }  </xhtml:p><xhtml:p>        Matcher matcher = pattern.matcher(text);  </xhtml:p><xhtml:p>        if(matcher.matches()) {  </xhtml:p><xhtml:p>            PhoneNumberModel phoneNumber = new PhoneNumberModel();  </xhtml:p><xhtml:p>            phoneNumber.setAreaCode(matcher.group(1));  </xhtml:p><xhtml:p>            phoneNumber.setPhoneNumber(matcher.group(2));  </xhtml:p><xhtml:p>            setValue(phoneNumber);  </xhtml:p><xhtml:p>        } else {  </xhtml:p><xhtml:p>            throw new IllegalArgumentException(String.format("类型转换失败，需要格式[010-12345678]，但格式是[%s]", text));  </xhtml:p><xhtml:p>        }  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    public String getAsText() {  </xhtml:p><xhtml:p>        PhoneNumberModel phoneNumber = ((PhoneNumberModel)getValue());  </xhtml:p><xhtml:p>        return phoneNumber == null ? "" : phoneNumber.getAreaCode() + "-" + phoneNumber.getPhoneNumber();  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>}  </xhtml:p></html><plain>PropertyEditorSupport：一个PropertyEditor的支持类；
setAsText：表示将String——&gt;PhoneNumberModel，根据正则表达式进行转换，如果转换失败抛出异常，则接下来的验证器会进行验证处理；
getAsText：表示将PhoneNumberModel——&gt;String。


public class PhoneNumberEditor extends PropertyEditorSupport {  
    Pattern pattern = Pattern.compile("^(\\d{3,4})-(\\d{7,8})$");  
    @Override  
    public void setAsText(String text) throws IllegalArgumentException {  
        if(text == null || !StringUtils.hasLength(text)) {  
            setValue(null); //如果没值，设值为null  
        }  
        Matcher matcher = pattern.matcher(text);  
        if(matcher.matches()) {  
            PhoneNumberModel phoneNumber = new PhoneNumberModel();  
            phoneNumber.setAreaCode(matcher.group(1));  
            phoneNumber.setPhoneNumber(matcher.group(2));  
            setValue(phoneNumber);  
        } else {  
            throw new IllegalArgumentException(String.format("类型转换失败，需要格式[010-12345678]，但格式是[%s]", text));  
        }  
    }  
    @Override  
    public String getAsText() {  
        PhoneNumberModel phoneNumber = ((PhoneNumberModel)getValue());  
        return phoneNumber == null ? "" : phoneNumber.getAreaCode() + "-" + phoneNumber.getPhoneNumber();  
    }  
}  </plain></notes></topic><topic id="3onvrvsjgjfnjuatiqesh037ll" timestamp="1392778249053"><title>3注册PropertyEditor</title><children><topics type="attached"><topic id="2i6vgjpno9r0ku77tea4fmentk" timestamp="1392778159122"><title>1使用WebDataBinder进行控制器级别注册PropertyEditor（控制器独享）</title><notes><html><xhtml:p>此处我们使用AbstractCommandController，因为它继承了BaseCommandController，拥有绑定流程</xhtml:p><xhtml:p/><xhtml:p>public class DataBinderTestController extends AbstractCommandController {  </xhtml:p><xhtml:p>    public DataBinderTestController() {  </xhtml:p><xhtml:p>        setCommandClass(DataBinderTestModel.class); //设置命令对象  </xhtml:p><xhtml:p>        setCommandName("dataBinderTest");//设置命令对象的名字  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    protected ModelAndView handle(HttpServletRequest req, HttpServletResponse resp, Object command, BindException errors) throws Exception {  </xhtml:p><xhtml:p>        //输出command对象看看是否绑定正确  </xhtml:p><xhtml:p>        System.out.println(command);  </xhtml:p><xhtml:p>        return new ModelAndView("bindAndValidate/success").addObject("dataBinderTest", command);  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {  </xhtml:p><xhtml:p>        super.initBinder(request, binder);  </xhtml:p><xhtml:p>        //注册自定义的属性编辑器  </xhtml:p><xhtml:p>        //1、日期  </xhtml:p><xhtml:p>        DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  </xhtml:p><xhtml:p>        CustomDateEditor dateEditor = new CustomDateEditor(df, true);  </xhtml:p><xhtml:p>        //表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换  </xhtml:p><xhtml:p>        binder.registerCustomEditor(Date.class, dateEditor);  </xhtml:p><xhtml:p>        //自定义的电话号码编辑器  </xhtml:p><xhtml:p>        binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>}  </xhtml:p></html><plain>此处我们使用AbstractCommandController，因为它继承了BaseCommandController，拥有绑定流程

public class DataBinderTestController extends AbstractCommandController {  
    public DataBinderTestController() {  
        setCommandClass(DataBinderTestModel.class); //设置命令对象  
        setCommandName("dataBinderTest");//设置命令对象的名字  
    }  
    @Override  
    protected ModelAndView handle(HttpServletRequest req, HttpServletResponse resp, Object command, BindException errors) throws Exception {  
        //输出command对象看看是否绑定正确  
        System.out.println(command);  
        return new ModelAndView("bindAndValidate/success").addObject("dataBinderTest", command);  
    }  
    @Override  
    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {  
        super.initBinder(request, binder);  
        //注册自定义的属性编辑器  
        //1、日期  
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
        CustomDateEditor dateEditor = new CustomDateEditor(df, true);  
        //表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换  
        binder.registerCustomEditor(Date.class, dateEditor);  
        //自定义的电话号码编辑器  
        binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());  
    }  
}  </plain></notes></topic><topic id="4figgej0onhcglps9vbehcrb5r" timestamp="1392778225994"><title>2使用WebBindingInitializer批量注册PropertyEditor</title><notes><html><xhtml:p>如果想在多个控制器同时注册多个相同的PropertyEditor时，可以考虑使用WebBindingInitializer</xhtml:p><xhtml:p/><xhtml:p>public class MyWebBindingInitializer implements WebBindingInitializer {  </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    public void initBinder(WebDataBinder binder, WebRequest request) {  </xhtml:p><xhtml:p>        //注册自定义的属性编辑器  </xhtml:p><xhtml:p>        //1、日期  </xhtml:p><xhtml:p>        DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  </xhtml:p><xhtml:p>        CustomDateEditor dateEditor = new CustomDateEditor(df, true);  </xhtml:p><xhtml:p>        //表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换  </xhtml:p><xhtml:p>        binder.registerCustomEditor(Date.class, dateEditor);  </xhtml:p><xhtml:p>        //自定义的电话号码编辑器  </xhtml:p><xhtml:p>        binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p/><xhtml:p>&lt;!-- 注册WebBindingInitializer实现 --&gt;  </xhtml:p><xhtml:p>&lt;bean id="myWebBindingInitializer" class="cn.javass.chapter4.web.controller.support.initializer.MyWebBindingInitializer"/&gt;  </xhtml:p><xhtml:p>&lt;bean name="/dataBind" class="cn.javass.chapter4.web.controller.DataBinderTestController"&gt;  </xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">    &lt;!-- 注入WebBindingInitializer实现 --&gt;  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">    &lt;property name="webBindingInitializer" ref="myWebBindingInitializer"/&gt;  </xhtml:span></xhtml:p><xhtml:p>&lt;/bean&gt;  </xhtml:p></html><plain>如果想在多个控制器同时注册多个相同的PropertyEditor时，可以考虑使用WebBindingInitializer

public class MyWebBindingInitializer implements WebBindingInitializer {  
    @Override  
    public void initBinder(WebDataBinder binder, WebRequest request) {  
        //注册自定义的属性编辑器  
        //1、日期  
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");  
        CustomDateEditor dateEditor = new CustomDateEditor(df, true);  
        //表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换  
        binder.registerCustomEditor(Date.class, dateEditor);  
        //自定义的电话号码编辑器  
        binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());  
    }  
}  

&lt;!-- 注册WebBindingInitializer实现 --&gt;  
&lt;bean id="myWebBindingInitializer" class="cn.javass.chapter4.web.controller.support.initializer.MyWebBindingInitializer"/&gt;  
&lt;bean name="/dataBind" class="cn.javass.chapter4.web.controller.DataBinderTestController"&gt;  
    &lt;!-- 注入WebBindingInitializer实现 --&gt;  
    &lt;property name="webBindingInitializer" ref="myWebBindingInitializer"/&gt;  
&lt;/bean&gt;  </plain></notes></topic><topic id="6ubgui6mpd6eagb8384vhvhdeo" timestamp="1392778438767"><title>3全局级别注册PropertyEditor（全局共享）</title><notes><html><xhtml:p>只需要将我们自定义的PropertyEditor放在和你的<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">模型类同包下</xhtml:span>即可，且你的Editor命名规则必须是“<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">模型类名Editor</xhtml:span>”，这样Spring会自动使用标准JavaBean架构进行自动识别</xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/05dagjh771h0ourqv0o9uvje4c.png"/></xhtml:p></html><plain>只需要将我们自定义的PropertyEditor放在和你的模型类同包下即可，且你的Editor命名规则必须是“模型类名Editor”，这样Spring会自动使用标准JavaBean架构进行自动识别
</plain></notes></topic></topics></children></topic><topic id="58qsk7mkhrlcofkve4lohl5ghh" timestamp="1392795448226"><title>4页面格式化显示</title><notes><html><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">EL phoneNumber:${dataBinderTest.phoneNumber}</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">EL state:${dataBinderTest.state}</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">EL date:${dataBinderTest.date}</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">视图页面的数据没有预期被格式化</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769"/></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769"/></xhtml:p><xhtml:p>//1、格式化单个命令/表单对象的值（好像比较麻烦，真心没有好办法）  </xhtml:p><xhtml:p>&lt;spring:bind path="dataBinderTest.phoneNumber"&gt;${status.value}&lt;/spring:bind&gt;   </xhtml:p><xhtml:p/><xhtml:p>//2、通过form标签，内部的表单标签会自动调用命令/表单对象属性对应的PropertyEditor进行格式化显示  </xhtml:p><xhtml:p>&lt;form:form commandName="dataBinderTest"&gt;  </xhtml:p><xhtml:p>    &lt;form:input path="phoneNumber"/&gt;&lt;!-- 如果出错会显示错误之前的数据而不是空 --&gt;  </xhtml:p><xhtml:p>&lt;/form:form&gt; </xhtml:p><xhtml:p/><xhtml:p>//3、显示验证失败后的错误信息  </xhtml:p><xhtml:p>&lt;form:errors&gt;&lt;/form:errors&gt;  </xhtml:p><xhtml:p/><xhtml:p>//4、&lt;spring:eval&gt;标签，自动调用ConversionService并选择相应的Converter SPI进行格式化展示  </xhtml:p><xhtml:p>&lt;spring:eval expression="dataBinderTest.phoneNumber"&gt;&lt;/spring:eval&gt;   </xhtml:p><xhtml:p>如上代码能工作的前提是在RequestMappingHandlerMapping配置了ConversionServiceExposingInterceptor，它的作用是暴露conversionService到请求中以便如&lt;spring:eval&gt;标签使用</xhtml:p></html><plain>EL phoneNumber:${dataBinderTest.phoneNumber}
EL state:${dataBinderTest.state}
EL date:${dataBinderTest.date}
视图页面的数据没有预期被格式化


//1、格式化单个命令/表单对象的值（好像比较麻烦，真心没有好办法）  
&lt;spring:bind path="dataBinderTest.phoneNumber"&gt;${status.value}&lt;/spring:bind&gt;   

//2、通过form标签，内部的表单标签会自动调用命令/表单对象属性对应的PropertyEditor进行格式化显示  
&lt;form:form commandName="dataBinderTest"&gt;  
    &lt;form:input path="phoneNumber"/&gt;&lt;!-- 如果出错会显示错误之前的数据而不是空 --&gt;  
&lt;/form:form&gt; 

//3、显示验证失败后的错误信息  
&lt;form:errors&gt;&lt;/form:errors&gt;  

//4、&lt;spring:eval&gt;标签，自动调用ConversionService并选择相应的Converter SPI进行格式化展示  
&lt;spring:eval expression="dataBinderTest.phoneNumber"&gt;&lt;/spring:eval&gt;   
如上代码能工作的前提是在RequestMappingHandlerMapping配置了ConversionServiceExposingInterceptor，它的作用是暴露conversionService到请求中以便如&lt;spring:eval&gt;标签使用</plain></notes></topic></topics></children></topic></topics></children><notes><html><xhtml:p><xhtml:img xhtml:src="xap:attachments/6ln2d4dhunkjtel94umk9mq63m.png"/><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">流程：</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">1、首先创建数据绑定器，在此此会创建ServletRequestDataBinder类的对象，并设置messageCodesResolver（错误码解析器）；</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">2、提供第一个扩展点，初始化数据绑定器，在此处我们可以覆盖该方法注册自定义的PropertyEditor（请求参数——&gt;命令对象属性的转换）；</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">3、进行数据绑定，即请求参数——&gt;命令对象的绑定；</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">4、提供第二个扩展点，数据绑定完成后的扩展点，此处可以实现一些自定义的绑定动作；</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">5、验证器对象的验证，验证器通过validators注入，如果验证失败，需要把错误信息放入Errors（此处使用BindException实现）；</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">6、提供第三个扩展点，此处可以实现自定义的绑定/验证逻辑；</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">7、将errors传入功能处理方法进行处理，功能方法应该判断该错误对象是否有错误进行相应的处理。</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"> </xhtml:span></xhtml:p></html><plain>
流程：
1、首先创建数据绑定器，在此此会创建ServletRequestDataBinder类的对象，并设置messageCodesResolver（错误码解析器）；
2、提供第一个扩展点，初始化数据绑定器，在此处我们可以覆盖该方法注册自定义的PropertyEditor（请求参数——&gt;命令对象属性的转换）；
3、进行数据绑定，即请求参数——&gt;命令对象的绑定；
4、提供第二个扩展点，数据绑定完成后的扩展点，此处可以实现一些自定义的绑定动作；
5、验证器对象的验证，验证器通过validators注入，如果验证失败，需要把错误信息放入Errors（此处使用BindException实现）；
6、提供第三个扩展点，此处可以实现自定义的绑定/验证逻辑；
7、将errors传入功能处理方法进行处理，功能方法应该判断该错误对象是否有错误进行相应的处理。
 </plain></notes></topic><topic id="7343lfu7k3k78tu5o6h6c52mpe" timestamp="1392779898343"><title>1.1.3数据验证器</title><children><topics type="attached"><topic id="5r24nm0kkcjdhbh0cu65epprmf" timestamp="1392779856291"><title>1在controller中使用BindException</title><notes><html><xhtml:p>public class ErrorController extends AbstractCommandController {  </xhtml:p><xhtml:p>       public ErrorController() {  </xhtml:p><xhtml:p>              setCommandClass(DataBinderTestModel.class);  </xhtml:p><xhtml:p>              setCommandName("command");  </xhtml:p><xhtml:p>       }  </xhtml:p><xhtml:p>       @Override  </xhtml:p><xhtml:p>       protected ModelAndView handle(HttpServletRequest req, HttpServletResponse resp, Object command, BindException errors) throws Exception {     </xhtml:p><xhtml:p>              //表示用户名不为空  </xhtml:p><xhtml:p>              errors.reject("<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">username.not.empty</xhtml:span>");  </xhtml:p><xhtml:p>              //带有默认错误消息  </xhtml:p><xhtml:p>              errors.reject("<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">username.not.empty1</xhtml:span>", "用户名不能为空1");  </xhtml:p><xhtml:p>              //带有参数和默认错误消息          </xhtml:p><xhtml:p>              errors.reject("<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">username.length.error</xhtml:span>", new Object[]{5, 10});  </xhtml:p><xhtml:p>              </xhtml:p><xhtml:p>              //得到错误相关的模型数据  </xhtml:p><xhtml:p>              Map model = errors.getModel();  </xhtml:p><xhtml:p>              return new ModelAndView("bindAndValidate/error", model);  </xhtml:p><xhtml:p>       }  </xhtml:p><xhtml:p>}  </xhtml:p></html><plain>public class ErrorController extends AbstractCommandController {  
       public ErrorController() {  
              setCommandClass(DataBinderTestModel.class);  
              setCommandName("command");  
       }  
       @Override  
       protected ModelAndView handle(HttpServletRequest req, HttpServletResponse resp, Object command, BindException errors) throws Exception {     
              //表示用户名不为空  
              errors.reject("username.not.empty");  
              //带有默认错误消息  
              errors.reject("username.not.empty1", "用户名不能为空1");  
              //带有参数和默认错误消息          
              errors.reject("username.length.error", new Object[]{5, 10});  
              
              //得到错误相关的模型数据  
              Map model = errors.getModel();  
              return new ModelAndView("bindAndValidate/error", model);  
       }  
}  </plain></notes><children><topics type="attached"><topic id="2aq5kut5og9m1qhrkqfrmn0sla" timestamp="1392779633042"><title>1Error接口</title><notes><html><xhtml:p>public interface Errors {  </xhtml:p><xhtml:p>  //=========================全局错误消息（验证/绑定对象全局的）=============================  </xhtml:p><xhtml:p>  //注册一个全局的错误码（）  </xhtml:p><xhtml:p>  void reject(String errorCode);  </xhtml:p><xhtml:p>  //注册一个全局的错误码，当根据errorCode没有找到相应错误消息时，使用defaultMessage作为错误消息  </xhtml:p><xhtml:p>  void reject(String errorCode, String defaultMessage);  </xhtml:p><xhtml:p>  //注册一个全局的错误码，当根据errorCode没有找到相应错误消息时（带错误参数的），使用defaultMessage作为错误消息  </xhtml:p><xhtml:p>  void reject(String errorCode, Object[] errorArgs, String defaultMessage);  </xhtml:p><xhtml:p>  //=========================全局错误消息（验证/绑定整个对象的）=============================  </xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>  //=========================局部错误消息（验证/绑定对象字段的）=============================  </xhtml:p><xhtml:p>  //注册一个对象字段的错误码，field指定验证失败的字段名  </xhtml:p><xhtml:p>  void rejectValue(String field, String errorCode);  </xhtml:p><xhtml:p>  void rejectValue(String field, String errorCode, String defaultMessage);  </xhtml:p><xhtml:p>  void rejectValue(String field, String errorCode, Object[] errorArgs, String defaultMessage);  </xhtml:p><xhtml:p>  //=========================局部错误消息（验证/绑定对象字段的）=============================  </xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>  boolean hasErrors();      ////是否有错误  </xhtml:p><xhtml:p>  boolean hasGlobalErrors(); //是否有全局错误  </xhtml:p><xhtml:p>  boolean hasFieldErrors();  //是否有字段错误  </xhtml:p><xhtml:p>  Object getFieldValue(String field); //返回当前验证通过的值，或验证失败时失败的值；  </xhtml:p><xhtml:p>}  </xhtml:p></html><plain>public interface Errors {  
  //=========================全局错误消息（验证/绑定对象全局的）=============================  
  //注册一个全局的错误码（）  
  void reject(String errorCode);  
  //注册一个全局的错误码，当根据errorCode没有找到相应错误消息时，使用defaultMessage作为错误消息  
  void reject(String errorCode, String defaultMessage);  
  //注册一个全局的错误码，当根据errorCode没有找到相应错误消息时（带错误参数的），使用defaultMessage作为错误消息  
  void reject(String errorCode, Object[] errorArgs, String defaultMessage);  
  //=========================全局错误消息（验证/绑定整个对象的）=============================  


  //=========================局部错误消息（验证/绑定对象字段的）=============================  
  //注册一个对象字段的错误码，field指定验证失败的字段名  
  void rejectValue(String field, String errorCode);  
  void rejectValue(String field, String errorCode, String defaultMessage);  
  void rejectValue(String field, String errorCode, Object[] errorArgs, String defaultMessage);  
  //=========================局部错误消息（验证/绑定对象字段的）=============================  


  boolean hasErrors();      ////是否有错误  
  boolean hasGlobalErrors(); //是否有全局错误  
  boolean hasFieldErrors();  //是否有字段错误  
  Object getFieldValue(String field); //返回当前验证通过的值，或验证失败时失败的值；  
}  </plain></notes></topic></topics></children></topic><topic id="6c0jjch3ngd0h2c2aafoe989b7" timestamp="1392779336636"><title>2配置国际化资源</title><notes><html><xhtml:p>&lt;bean id="messageSource"  </xhtml:p><xhtml:p>       class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;  </xhtml:p><xhtml:p>    &lt;property name="basename" value="classpath:messages"/&gt;  </xhtml:p><xhtml:p>    &lt;property name="fileEncodings" value="utf-8"/&gt;  </xhtml:p><xhtml:p>    &lt;property name="cacheSeconds" value="120"/&gt;  </xhtml:p><xhtml:p>&lt;/bean&gt;  </xhtml:p><xhtml:p>   </xhtml:p><xhtml:p>&lt;bean name="/error" class="cn.javass.chapter4.web.controller.ErrorController"/&gt;  </xhtml:p><xhtml:p/><xhtml:p>messageSource：用于获取错误码对应的错误消息的，而且<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">bean名字默认必须是messageSource</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">messages.properties（需要执行NativeToAscii）</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p/></html><plain>&lt;bean id="messageSource"  
       class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;  
    &lt;property name="basename" value="classpath:messages"/&gt;  
    &lt;property name="fileEncodings" value="utf-8"/&gt;  
    &lt;property name="cacheSeconds" value="120"/&gt;  
&lt;/bean&gt;  
   
&lt;bean name="/error" class="cn.javass.chapter4.web.controller.ErrorController"/&gt;  

messageSource：用于获取错误码对应的错误消息的，而且bean名字默认必须是messageSource
messages.properties（需要执行NativeToAscii）

</plain></notes></topic><topic id="28vqigjdo76k7dncidci8rv3db" timestamp="1392779182130"><title>3显示错误信息</title><notes><html><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">&lt;%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt; </xhtml:span> </xhtml:p><xhtml:p>&lt;!-- 表单的默认命令对象名为command --&gt;  </xhtml:p><xhtml:p>&lt;form:form commandName="command"&gt;  </xhtml:p><xhtml:p>   <xhtml:span style-id="6gfbflslb1ron2msrf5b67t769"> &lt;form:errors path="*" cssStyle="color:red"</xhtml:span><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">&gt;&lt;/form:errors&gt;  </xhtml:span> </xhtml:p><xhtml:p>    bool:&lt;form:input path="bool"/&gt;&lt;br/&gt;  </xhtml:p><xhtml:p>    phoneNumber:&lt;form:input path="phoneNumber"/&gt;&lt;br/&gt;  </xhtml:p><xhtml:p>    date:&lt;form:input path="date"/&gt;&lt;br/&gt;  </xhtml:p><xhtml:p>    &lt;input type="submit" value="提交"/&gt;  </xhtml:p><xhtml:p>&lt;/form:form&gt; </xhtml:p><xhtml:p/><xhtml:p>form标签库：此处我们使用了spring的form标签库；</xhtml:p><xhtml:p>&lt;form:form commandName="command"&gt;:表示我们的表单标签，commandName表示绑定的命令对象名字，默认为command</xhtml:p><xhtml:p>&lt;form:errors path="*"&gt;&lt;/form:errors&gt;：表示显示错误信息的标签，如果path为“*”表示显示所有错误信息</xhtml:p><xhtml:p>&lt;form:input path="bool"/&gt;：等价于（&lt;input type=’text’&gt;），但会从命令对象中取出bool属性进行填充value属性，或<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">如果表单提交有错误会从错误对象取出之前的错误数据（而非空或默认值）</xhtml:span></xhtml:p><xhtml:p>&lt;input type="submit" value="提交"/&gt;：spring没有提供相应的提交按钮，因此需要使用html的</xhtml:p><xhtml:p/><xhtml:p/></html><plain>&lt;%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;  
&lt;!-- 表单的默认命令对象名为command --&gt;  
&lt;form:form commandName="command"&gt;  
    &lt;form:errors path="*" cssStyle="color:red"&gt;&lt;/form:errors&gt;   
    bool:&lt;form:input path="bool"/&gt;&lt;br/&gt;  
    phoneNumber:&lt;form:input path="phoneNumber"/&gt;&lt;br/&gt;  
    date:&lt;form:input path="date"/&gt;&lt;br/&gt;  
    &lt;input type="submit" value="提交"/&gt;  
&lt;/form:form&gt; 

form标签库：此处我们使用了spring的form标签库；
&lt;form:form commandName="command"&gt;:表示我们的表单标签，commandName表示绑定的命令对象名字，默认为command
&lt;form:errors path="*"&gt;&lt;/form:errors&gt;：表示显示错误信息的标签，如果path为“*”表示显示所有错误信息
&lt;form:input path="bool"/&gt;：等价于（&lt;input type=’text’&gt;），但会从命令对象中取出bool属性进行填充value属性，或如果表单提交有错误会从错误对象取出之前的错误数据（而非空或默认值）
&lt;input type="submit" value="提交"/&gt;：spring没有提供相应的提交按钮，因此需要使用html的

</plain></notes></topic><topic id="7eb3j6tmg78mnrfe4lna3q06b9" timestamp="1392779896491"><title>4自动数据绑定错误，消息国际化显示</title><notes><html><xhtml:p>数据绑定失败（类型不匹配）会自动生成如下错误码（错误码对应的错误消息按照如下顺序依次查找）：</xhtml:p><xhtml:p>1、typeMismatch.命令对象名.属性名</xhtml:p><xhtml:p>2、typeMismatch.属性名</xhtml:p><xhtml:p>3、typeMismatch.属性全限定类名（包名.类名）</xhtml:p><xhtml:p>4、typeMismatch</xhtml:p><xhtml:p/><xhtml:p>⊙内部使用MessageCodesResolver解析数据绑定错误到错误码，默认DefaultMessageCodesResolver，因此想要详细了解如何解析请看其javadoc</xhtml:p><xhtml:p>⊙建议使用第1个进行错误码的配置</xhtml:p><xhtml:p/><xhtml:p>messages.properties（需要执行NativeToAscii）：</xhtml:p><xhtml:p>typeMismatch.dataBinderTest.date=您输入的数据格式错误，请重新输入（格式：2012-03-19 22:17:17）</xhtml:p><xhtml:p>#typeMismatch.date=2</xhtml:p><xhtml:p>#typeMismatch.java.util.Date=3</xhtml:p><xhtml:p>#typeMismatch=4</xhtml:p><xhtml:p/></html><plain>数据绑定失败（类型不匹配）会自动生成如下错误码（错误码对应的错误消息按照如下顺序依次查找）：
1、typeMismatch.命令对象名.属性名
2、typeMismatch.属性名
3、typeMismatch.属性全限定类名（包名.类名）
4、typeMismatch

⊙内部使用MessageCodesResolver解析数据绑定错误到错误码，默认DefaultMessageCodesResolver，因此想要详细了解如何解析请看其javadoc
⊙建议使用第1个进行错误码的配置

messages.properties（需要执行NativeToAscii）：
typeMismatch.dataBinderTest.date=您输入的数据格式错误，请重新输入（格式：2012-03-19 22:17:17）
#typeMismatch.date=2
#typeMismatch.java.util.Date=3
#typeMismatch=4
</plain></notes></topic><topic id="6t5gcs2sq95qiaun29k0pov24g" timestamp="1392780088442"><title>5自定义验证Validator</title><children><topics type="attached"><topic id="7otd1fgggfjsf8dr6hp74u109o" timestamp="1392780128835"><title>1编写Validator实现</title><notes><html><xhtml:p/><xhtml:p>Validator接口：验证器，编程实现数据验证的接口；</xhtml:p><xhtml:p>supports方法：当前验证器是否支持指定的clazz验证，如果支持返回true即可；</xhtml:p><xhtml:p>validate方法：验证的具体方法，target参数表示要验证的目标对象（如命令对象），errors表示验证出错后存放错误信息的错误对象。</xhtml:p><xhtml:p/><xhtml:p>public class UserModelValidator implements Validator {  </xhtml:p><xhtml:p>    private static final Pattern USERNAME_PATTERN = Pattern.compile("[a-zA-Z]\\w{4,19}");  </xhtml:p><xhtml:p>    private static final Pattern PASSWORD_PATTERN = Pattern.compile("[a-zA-Z0-9]{5,20}");  </xhtml:p><xhtml:p>    private static final Set&lt;String&gt; FORBINDDDEN_WORD_SET = new HashSet&lt;String&gt;();  </xhtml:p><xhtml:p>    static {  </xhtml:p><xhtml:p>       FORBINDDDEN_WORD_SET.add("fuck"); //删掉空格  </xhtml:p><xhtml:p>       FORBINDDDEN_WORD_SET.add("admin");  </xhtml:p><xhtml:p>    }    </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    public boolean supports(Class&lt;?&gt; clazz) {  </xhtml:p><xhtml:p>       return UserModel.class == clazz;//表示只对UserModel类型的目标对象实施验证  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    public void validate(Object target, Errors errors) {  </xhtml:p><xhtml:p>       //这个表示如果目标对象的username属性为空，则表示错误（简化我们手工判断是否为空）  </xhtml:p><xhtml:p>       ValidationUtils.rejectIfEmpty(errors, "username", "username.not.empty");  </xhtml:p><xhtml:p>        </xhtml:p><xhtml:p>       UserModel user = (UserModel) target;  </xhtml:p><xhtml:p>        </xhtml:p><xhtml:p>       if(!USERNAME_PATTERN.matcher(user.getUsername()).matches()) {  </xhtml:p><xhtml:p>           errors.rejectValue("username", "username.not.illegal");//如果用户名不合法  </xhtml:p><xhtml:p>       }  </xhtml:p><xhtml:p>        </xhtml:p><xhtml:p>       for(String forbiddenWord : FORBINDDDEN_WORD_SET) {  </xhtml:p><xhtml:p>           if(user.getUsername().contains(forbiddenWord)) {  </xhtml:p><xhtml:p>              errors.rejectValue("username", "username.forbidden", new Object[]{forbiddenWord}, "您的用户名包含非法关键词");//用户名包含屏蔽关键字  </xhtml:p><xhtml:p>              break;  </xhtml:p><xhtml:p>           }  </xhtml:p><xhtml:p>       }  </xhtml:p><xhtml:p>       if(!PASSWORD_PATTERN.matcher(user.getPassword()).matches()) {  </xhtml:p><xhtml:p>           errors.rejectValue("password","password.not.illegal", "密码不合法");//密码不合法  </xhtml:p><xhtml:p>       }    </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>}  </xhtml:p></html><plain>
Validator接口：验证器，编程实现数据验证的接口；
supports方法：当前验证器是否支持指定的clazz验证，如果支持返回true即可；
validate方法：验证的具体方法，target参数表示要验证的目标对象（如命令对象），errors表示验证出错后存放错误信息的错误对象。

public class UserModelValidator implements Validator {  
    private static final Pattern USERNAME_PATTERN = Pattern.compile("[a-zA-Z]\\w{4,19}");  
    private static final Pattern PASSWORD_PATTERN = Pattern.compile("[a-zA-Z0-9]{5,20}");  
    private static final Set&lt;String&gt; FORBINDDDEN_WORD_SET = new HashSet&lt;String&gt;();  
    static {  
       FORBINDDDEN_WORD_SET.add("fuck"); //删掉空格  
       FORBINDDDEN_WORD_SET.add("admin");  
    }    
    @Override  
    public boolean supports(Class&lt;?&gt; clazz) {  
       return UserModel.class == clazz;//表示只对UserModel类型的目标对象实施验证  
    }  
    @Override  
    public void validate(Object target, Errors errors) {  
       //这个表示如果目标对象的username属性为空，则表示错误（简化我们手工判断是否为空）  
       ValidationUtils.rejectIfEmpty(errors, "username", "username.not.empty");  
        
       UserModel user = (UserModel) target;  
        
       if(!USERNAME_PATTERN.matcher(user.getUsername()).matches()) {  
           errors.rejectValue("username", "username.not.illegal");//如果用户名不合法  
       }  
        
       for(String forbiddenWord : FORBINDDDEN_WORD_SET) {  
           if(user.getUsername().contains(forbiddenWord)) {  
              errors.rejectValue("username", "username.forbidden", new Object[]{forbiddenWord}, "您的用户名包含非法关键词");//用户名包含屏蔽关键字  
              break;  
           }  
       }  
       if(!PASSWORD_PATTERN.matcher(user.getPassword()).matches()) {  
           errors.rejectValue("password","password.not.illegal", "密码不合法");//密码不合法  
       }    
    }  
}  </plain></notes></topic><topic id="4ssibjsljqe82m4bd3q370keke" timestamp="1392780222475"><title>2为controller配置validator</title><notes><html><xhtml:p>&lt;bean id="userModelValidator"  class="cn.javass.chapter4.web.controller.support.validator.UserModelValidator"/&gt;  </xhtml:p><xhtml:p/><xhtml:p>&lt;bean name="/validator"  class="cn.javass.chapter4.web.controller.RegisterSimpleFormController"&gt;  </xhtml:p><xhtml:p>    &lt;property name="formView" value="registerAndValidator"/&gt;  </xhtml:p><xhtml:p>    &lt;property name="successView" value="redirect:/success"/&gt;  </xhtml:p><xhtml:p>    &lt;property name="validator" ref="userModelValidator"/&gt;  </xhtml:p><xhtml:p>&lt;/bean&gt; </xhtml:p><xhtml:p/><xhtml:p/><xhtml:p/><xhtml:p>public class <xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">RegisterSimpleFormController</xhtml:span> extends SimpleFormController {</xhtml:p><xhtml:p>	public RegisterSimpleFormController() {</xhtml:p><xhtml:p>		//设置命令对象实现类</xhtml:p><xhtml:p>		setCommandClass(UserModel.class);</xhtml:p><xhtml:p>		//设置命令对象的名字</xhtml:p><xhtml:p>		setCommandName("user");</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	//form object 表单对象，提供展示表单时的表单数据（使用commandName放入请求）</xhtml:p><xhtml:p>	@Override</xhtml:p><xhtml:p>	protected Object formBackingObject(HttpServletRequest request) throws Exception {</xhtml:p><xhtml:p>		UserModel user = new UserModel();</xhtml:p><xhtml:p>		user.setUsername("请输入用户名");</xhtml:p><xhtml:p>		return user;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	//提供展示表单时需要的一些其他数据</xhtml:p><xhtml:p>	@Override</xhtml:p><xhtml:p>	protected Map referenceData(HttpServletRequest request) throws Exception {</xhtml:p><xhtml:p>		Map map = new HashMap();</xhtml:p><xhtml:p>		map.put("cityList", Arrays.asList("山东", "北京", "上海"));</xhtml:p><xhtml:p>		return map;</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>	@Override</xhtml:p><xhtml:p>	protected void doSubmitAction(Object command) throws Exception {</xhtml:p><xhtml:p>		UserModel user = (UserModel) command;</xhtml:p><xhtml:p>		//TODO 调用业务对象处理</xhtml:p><xhtml:p>		System.out.println(user);</xhtml:p><xhtml:p>	}</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>&lt;bean id="userModelValidator"  class="cn.javass.chapter4.web.controller.support.validator.UserModelValidator"/&gt;  

&lt;bean name="/validator"  class="cn.javass.chapter4.web.controller.RegisterSimpleFormController"&gt;  
    &lt;property name="formView" value="registerAndValidator"/&gt;  
    &lt;property name="successView" value="redirect:/success"/&gt;  
    &lt;property name="validator" ref="userModelValidator"/&gt;  
&lt;/bean&gt; 



public class RegisterSimpleFormController extends SimpleFormController {
	public RegisterSimpleFormController() {
		//设置命令对象实现类
		setCommandClass(UserModel.class);
		//设置命令对象的名字
		setCommandName("user");
	}
	//form object 表单对象，提供展示表单时的表单数据（使用commandName放入请求）
	@Override
	protected Object formBackingObject(HttpServletRequest request) throws Exception {
		UserModel user = new UserModel();
		user.setUsername("请输入用户名");
		return user;
	}
	//提供展示表单时需要的一些其他数据
	@Override
	protected Map referenceData(HttpServletRequest request) throws Exception {
		Map map = new HashMap();
		map.put("cityList", Arrays.asList("山东", "北京", "上海"));
		return map;
	}
	@Override
	protected void doSubmitAction(Object command) throws Exception {
		UserModel user = (UserModel) command;
		//TODO 调用业务对象处理
		System.out.println(user);
	}
}
</plain></notes></topic><topic id="3fjv9qa31keanmlr329urk13io" timestamp="1392780095780"><title>3页面显示</title><notes><html><xhtml:p>&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;  </xhtml:p><xhtml:p>&lt;%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;  </xhtml:p><xhtml:p>&lt;form:form commandName="user"&gt;  </xhtml:p><xhtml:p>   </xhtml:p><xhtml:p>&lt;form:errors path="*" cssStyle="color:red"&gt;&lt;/form:errors&gt;&lt;br/&gt;  </xhtml:p><xhtml:p>   </xhtml:p><xhtml:p>username:&lt;form:input path="username"/&gt;  </xhtml:p><xhtml:p>&lt;form:errors path="username" cssStyle="color:red"&gt;&lt;/form:errors&gt;  </xhtml:p><xhtml:p>&lt;br/&gt;  </xhtml:p><xhtml:p>   </xhtml:p><xhtml:p>password:&lt;form:password path="password"/&gt;  </xhtml:p><xhtml:p>&lt;form:errors path="password" cssStyle="color:red"&gt;&lt;/form:errors&gt;  </xhtml:p><xhtml:p>&lt;br/&gt;  </xhtml:p><xhtml:p>&lt;input type="submit" value="注册"/&gt;  </xhtml:p><xhtml:p>&lt;/form:form&gt;  </xhtml:p><xhtml:p>   </xhtml:p></html><plain>&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;  
&lt;%@taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;  
&lt;form:form commandName="user"&gt;  
   
&lt;form:errors path="*" cssStyle="color:red"&gt;&lt;/form:errors&gt;&lt;br/&gt;  
   
username:&lt;form:input path="username"/&gt;  
&lt;form:errors path="username" cssStyle="color:red"&gt;&lt;/form:errors&gt;  
&lt;br/&gt;  
   
password:&lt;form:password path="password"/&gt;  
&lt;form:errors path="password" cssStyle="color:red"&gt;&lt;/form:errors&gt;  
&lt;br/&gt;  
&lt;input type="submit" value="注册"/&gt;  
&lt;/form:form&gt;  
   </plain></notes></topic></topics></children><notes><html><xhtml:p>package org.springframework.validation;  </xhtml:p><xhtml:p>public interface Validator {  </xhtml:p><xhtml:p>	boolean supports(Class&lt;?&gt; clazz);  </xhtml:p><xhtml:p>	void validate(Object target, Errors errors);  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p/></html><plain>package org.springframework.validation;  
public interface Validator {  
	boolean supports(Class&lt;?&gt; clazz);  
	void validate(Object target, Errors errors);  
}  
</plain></notes></topic></topics></children></topic><topic id="3gmis080hkmb9ca9be724jecjg" timestamp="1392791694645"><title>1.1.4MethodNameResolver</title><children><topics type="attached"><topic id="6rdh0v74g55h52t9oelb0t8bgh" timestamp="1392791572442"><title>1、InternalPathMethodNameResolver</title><notes><html><xhtml:p>MultiActionController的默认实现</xhtml:p><xhtml:p>提供从请求URL路径解析功能方法的方法名，从请求的最后一个路径（/）开始，并忽略扩展名</xhtml:p><xhtml:p>如请求URL是“/user/list.html”，则解析的功能处理方法名为“list”，即调用list方法</xhtml:p><xhtml:p>该解析器还可以指定前缀和后缀，通过prefix和suffix属性，如指定prefix=”test_”,则功能方法名将变为test_list</xhtml:p></html><plain>MultiActionController的默认实现
提供从请求URL路径解析功能方法的方法名，从请求的最后一个路径（/）开始，并忽略扩展名
如请求URL是“/user/list.html”，则解析的功能处理方法名为“list”，即调用list方法
该解析器还可以指定前缀和后缀，通过prefix和suffix属性，如指定prefix=”test_”,则功能方法名将变为test_list</plain></notes></topic><topic id="56ucqq5d7gtecc7e15cn874ljm" timestamp="1392791693954"><title>2、ParameterMethodNameResolver</title><notes><html><xhtml:p>提供从请求参数解析功能处理方法的方法名，并按照如下顺序进行解析：</xhtml:p><xhtml:p>（1、methodParamNames：根据请求的参数名解析功能方法名（功能方法名和参数名同名）；</xhtml:p><xhtml:p>  &lt;property name="methodParamNames" value="list,create,update"/&gt;         </xhtml:p><xhtml:p>  如上配置时，如果请求中含有参数名list、create、update时，则功能处理方法名为list、create、update，这种方式的可以在当一个表单有多个提交按钮时使用，不同的提交按钮名字不一样即可。</xhtml:p><xhtml:p>  ParameterMethodNameResolver也考虑到图片提交按钮提交问题：</xhtml:p><xhtml:p>  &lt;input type="image" name="list"&gt; 和submit类似可以提交表单，单击该图片后会发送两个参数“list.x=x轴坐标”和“list.y=y轴坐标”（如提交后会变为list.x=7&amp;list.y=5）；因此我们配置的参数名（如list）在会加上“.x” 和 “.y”进行匹配。</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>（2、paramName：根据请求参数名的值解析功能方法名，默认的参数名是action，即请求的参数中含有“action=query”，则功能处理方法名为query；</xhtml:p><xhtml:p>（3、logicalMappings：逻辑功能方法名到真实功能方法名映射，如下所示：</xhtml:p><xhtml:p>  &lt;property name="logicalMappings"&gt;  </xhtml:p><xhtml:p>      &lt;props&gt;  </xhtml:p><xhtml:p>         &lt;prop key="doList"&gt;list&lt;/prop&gt;  </xhtml:p><xhtml:p>      &lt;/props&gt;  </xhtml:p><xhtml:p>  &lt;/property&gt;  </xhtml:p><xhtml:p>  即如果步骤1或2解析出逻辑功能方法名为doList（逻辑的），将会被重新映射为list功能方法名（真正执行的）。</xhtml:p><xhtml:p>（4、defaultMethodName：默认的方法名，当以上策略失败时默认调用的方法名。</xhtml:p></html><plain>提供从请求参数解析功能处理方法的方法名，并按照如下顺序进行解析：
（1、methodParamNames：根据请求的参数名解析功能方法名（功能方法名和参数名同名）；
  &lt;property name="methodParamNames" value="list,create,update"/&gt;         
  如上配置时，如果请求中含有参数名list、create、update时，则功能处理方法名为list、create、update，这种方式的可以在当一个表单有多个提交按钮时使用，不同的提交按钮名字不一样即可。
  ParameterMethodNameResolver也考虑到图片提交按钮提交问题：
  &lt;input type="image" name="list"&gt; 和submit类似可以提交表单，单击该图片后会发送两个参数“list.x=x轴坐标”和“list.y=y轴坐标”（如提交后会变为list.x=7&amp;list.y=5）；因此我们配置的参数名（如list）在会加上“.x” 和 “.y”进行匹配。
 
（2、paramName：根据请求参数名的值解析功能方法名，默认的参数名是action，即请求的参数中含有“action=query”，则功能处理方法名为query；
（3、logicalMappings：逻辑功能方法名到真实功能方法名映射，如下所示：
  &lt;property name="logicalMappings"&gt;  
      &lt;props&gt;  
         &lt;prop key="doList"&gt;list&lt;/prop&gt;  
      &lt;/props&gt;  
  &lt;/property&gt;  
  即如果步骤1或2解析出逻辑功能方法名为doList（逻辑的），将会被重新映射为list功能方法名（真正执行的）。
（4、defaultMethodName：默认的方法名，当以上策略失败时默认调用的方法名。</plain></notes></topic><topic id="1n8ntvs61mj8be4tdma9ggg253" timestamp="1392791894792"><title>3、PropertiesMethodNameResolver</title><notes><html><xhtml:p>提供自定义的从请求URL解析功能方法的方法名，使用一组用户自定义的模式到功能方法名的映射，映射使用Properties对象存放，具体配置示例如下：</xhtml:p><xhtml:p/><xhtml:p>&lt;bean id="propertiesMethodNameResolver" class="org.springframework.web.servlet.mvc.multiaction.PropertiesMethodNameResolver"&gt;  </xhtml:p><xhtml:p>    &lt;property name="mappings"&gt;  </xhtml:p><xhtml:p>        &lt;props&gt;  </xhtml:p><xhtml:p>              &lt;prop key="/create"&gt;create&lt;/prop&gt;  </xhtml:p><xhtml:p>              &lt;prop key="/update"&gt;update&lt;/prop&gt;  </xhtml:p><xhtml:p>              &lt;prop key="/delete"&gt;delete&lt;/prop&gt;  </xhtml:p><xhtml:p>              &lt;prop key="/list"&gt;list&lt;/prop&gt;  </xhtml:p><xhtml:p>              &lt;!-- 默认的行为 --&gt;  </xhtml:p><xhtml:p>              &lt;prop key="/**"&gt;list&lt;/prop&gt;  </xhtml:p><xhtml:p>        &lt;/props&gt;  </xhtml:p><xhtml:p>    &lt;/property&gt;  </xhtml:p><xhtml:p>&lt;/bean&gt;   </xhtml:p><xhtml:p>对于/create请求将调用create方法，Spring内部使用PathMatcher进行匹配（默认实现是AntPathMatcher）</xhtml:p><xhtml:p/></html><plain>提供自定义的从请求URL解析功能方法的方法名，使用一组用户自定义的模式到功能方法名的映射，映射使用Properties对象存放，具体配置示例如下：

&lt;bean id="propertiesMethodNameResolver" class="org.springframework.web.servlet.mvc.multiaction.PropertiesMethodNameResolver"&gt;  
    &lt;property name="mappings"&gt;  
        &lt;props&gt;  
              &lt;prop key="/create"&gt;create&lt;/prop&gt;  
              &lt;prop key="/update"&gt;update&lt;/prop&gt;  
              &lt;prop key="/delete"&gt;delete&lt;/prop&gt;  
              &lt;prop key="/list"&gt;list&lt;/prop&gt;  
              &lt;!-- 默认的行为 --&gt;  
              &lt;prop key="/**"&gt;list&lt;/prop&gt;  
        &lt;/props&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;   
对于/create请求将调用create方法，Spring内部使用PathMatcher进行匹配（默认实现是AntPathMatcher）
</plain></notes></topic></topics></children></topic><topic id="4bqv8b58h5bpit35qn24srsbp7" timestamp="1392791754448"><title>1.1.5RequestToViewNameTranslator</title><children><topics type="attached"><topic id="15r2i0mjdnqnscsphchavoojec" timestamp="1392791790952"><title>1、DefaultRequestToViewNameTranslator</title><notes><html><xhtml:p>用于直接将请求转换为逻辑视图名。默认实现为DefaultRequestToViewNameTranslator。</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>1、DefaultRequestToViewNameTranslator：将请求URL转换为逻辑视图名，默认规则如下：</xhtml:p><xhtml:p>  http://localhost:9080/web上下文/list -------&gt; 逻辑视图名为list</xhtml:p><xhtml:p>  http://localhost:9080/web上下文/list.html -------&gt; 逻辑视图名为list(默认删除扩展名)</xhtml:p><xhtml:p>  http://localhost:9080/web上下文/user/list.html -------&gt; 逻辑视图名为user/list</xhtml:p><xhtml:p/></html><plain>用于直接将请求转换为逻辑视图名。默认实现为DefaultRequestToViewNameTranslator。
 
1、DefaultRequestToViewNameTranslator：将请求URL转换为逻辑视图名，默认规则如下：
  http://localhost:9080/web上下文/list -------&gt; 逻辑视图名为list
  http://localhost:9080/web上下文/list.html -------&gt; 逻辑视图名为list(默认删除扩展名)
  http://localhost:9080/web上下文/user/list.html -------&gt; 逻辑视图名为user/list
</plain></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic><topic id="0hohjonpvr8psc0u8pemi3dhfd" timestamp="1392780734760"><title>2处理器拦截器</title><children><topics type="attached"><topic id="6pmhfuka3o3e22j39pu2bmtcf2" timestamp="1392780393351"><title>1、实现接口HandlerInterceptor或者继承HandlerInterceptorAdapter</title></topic><topic id="07b3592toi97apcbjks4bjhsgg" timestamp="1392780641891"><title>2、Interceptor实现过程</title><notes><html><xhtml:p><xhtml:img xhtml:src="xap:attachments/7abbq7a4r4931h6e4m9eqm3tns.png"/><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/11kldlhb506n4iopcsn03vvvq7.png"/></xhtml:p></html><plain>
</plain></notes></topic><topic id="0f11sncf2men7e2kmpivobe5k6" timestamp="1392780595178"><title>3、配置方式</title><children><topics type="attached"><topic id="6kgv1f8l4g7bbrabc6t25bf3ae" timestamp="1392780531941"><title>1、mvc:interceptors</title><notes><html><xhtml:p/><xhtml:p>	&lt;mvc:interceptors&gt;</xhtml:p><xhtml:p>		&lt;mvc:interceptor&gt;</xhtml:p><xhtml:p>			&lt;mvc:mapping path="/qiye/**/*.do"/&gt;</xhtml:p><xhtml:p>			&lt;bean class="com.totyu.web.interceptor.SignonInterceptor" /&gt;</xhtml:p><xhtml:p>		&lt;/mvc:interceptor&gt;</xhtml:p><xhtml:p>	&lt;/mvc:interceptors&gt;</xhtml:p></html><plain>
	&lt;mvc:interceptors&gt;
		&lt;mvc:interceptor&gt;
			&lt;mvc:mapping path="/qiye/**/*.do"/&gt;
			&lt;bean class="com.totyu.web.interceptor.SignonInterceptor" /&gt;
		&lt;/mvc:interceptor&gt;
	&lt;/mvc:interceptors&gt;</plain></notes></topic><topic id="25o5c66cl239ek598kb83kg6v4" timestamp="1392780566033"><title>2、配置HandlerMapping</title><notes><html><xhtml:p>&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;  </xhtml:p><xhtml:p>    &lt;property name="interceptors"&gt;  </xhtml:p><xhtml:p>        &lt;list&gt;  </xhtml:p><xhtml:p>           &lt;ref bean="handlerInterceptor1"/&gt;  </xhtml:p><xhtml:p>          &lt;ref bean="handlerInterceptor2"/&gt;  </xhtml:p><xhtml:p>        &lt;/list&gt;  </xhtml:p><xhtml:p>    &lt;/property&gt;  </xhtml:p><xhtml:p>&lt;/bean&gt;  </xhtml:p></html><plain>&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;  
    &lt;property name="interceptors"&gt;  
        &lt;list&gt;  
           &lt;ref bean="handlerInterceptor1"/&gt;  
          &lt;ref bean="handlerInterceptor2"/&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;  </plain></notes></topic></topics></children></topic><topic id="013eip9sbtpua8sh1ihtv9att6" timestamp="1392780781401"><title>4、示例，利用ThreadLocal，记录方法执行时间</title><notes><html><xhtml:p>public class StopWatchHandlerInterceptor extends HandlerInterceptorAdapter {  </xhtml:p><xhtml:p>    private NamedThreadLocal&lt;Long&gt;  startTimeThreadLocal =   </xhtml:p><xhtml:p>new NamedThreadLocal&lt;Long&gt;("StopWatch-StartTime");  </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,   </xhtml:p><xhtml:p>Object handler) throws Exception {  </xhtml:p><xhtml:p>        long beginTime = System.currentTimeMillis();//1、开始时间  </xhtml:p><xhtml:p>        startTimeThreadLocal.set(beginTime);//线程绑定变量（该数据只有当前请求的线程可见）  </xhtml:p><xhtml:p>        return true;//继续流程  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>      </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,   </xhtml:p><xhtml:p>Object handler, Exception ex) throws Exception {  </xhtml:p><xhtml:p>        long endTime = System.currentTimeMillis();//2、结束时间  </xhtml:p><xhtml:p>        long beginTime = startTimeThreadLocal.get();//得到线程绑定的局部变量（开始时间）  </xhtml:p><xhtml:p>        long consumeTime = endTime - beginTime;//3、消耗的时间  </xhtml:p><xhtml:p>        if(consumeTime &gt; 500) {//此处认为处理时间超过500毫秒的请求为慢请求  </xhtml:p><xhtml:p>            //TODO 记录到日志文件  </xhtml:p><xhtml:p>            System.out.println(  </xhtml:p><xhtml:p>String.format("%s consume %d millis", request.getRequestURI(), consumeTime));  </xhtml:p><xhtml:p>        }          </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>}  </xhtml:p></html><plain>public class StopWatchHandlerInterceptor extends HandlerInterceptorAdapter {  
    private NamedThreadLocal&lt;Long&gt;  startTimeThreadLocal =   
new NamedThreadLocal&lt;Long&gt;("StopWatch-StartTime");  
    @Override  
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,   
Object handler) throws Exception {  
        long beginTime = System.currentTimeMillis();//1、开始时间  
        startTimeThreadLocal.set(beginTime);//线程绑定变量（该数据只有当前请求的线程可见）  
        return true;//继续流程  
    }  
      
    @Override  
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,   
Object handler, Exception ex) throws Exception {  
        long endTime = System.currentTimeMillis();//2、结束时间  
        long beginTime = startTimeThreadLocal.get();//得到线程绑定的局部变量（开始时间）  
        long consumeTime = endTime - beginTime;//3、消耗的时间  
        if(consumeTime &gt; 500) {//此处认为处理时间超过500毫秒的请求为慢请求  
            //TODO 记录到日志文件  
            System.out.println(  
String.format("%s consume %d millis", request.getRequestURI(), consumeTime));  
        }          
    }  
}  </plain></notes></topic></topics></children></topic><topic id="34u5tahm8mhubdihdamer1o5a3" timestamp="1392788837389"><title>3</title><children><topics type="attached"><topic id="01jr8urbfqe63rifp27uao46nk" timestamp="1392795176120"><title>1.2Annotation注释方式</title><notes><html><xhtml:p>Spring2.5引入注解式处理器支持，通过@Controller 和 @RequestMapping注解定义我们的处理器类。</xhtml:p><xhtml:p>并且提供了一组强大的注解：</xhtml:p><xhtml:p>需要通过处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter来开启支持@Controller 和 @RequestMapping注解的处理器。</xhtml:p><xhtml:p>@Controller：用于标识是处理器类；</xhtml:p><xhtml:p>@RequestMapping：请求到处理器功能方法的映射规则；</xhtml:p><xhtml:p>@RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；</xhtml:p><xhtml:p>@ModelAttribute：请求参数到命令对象的绑定；</xhtml:p><xhtml:p>@SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；</xhtml:p><xhtml:p>@<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">InitBinder</xhtml:span>：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>Spring3.0引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持：</xhtml:p><xhtml:p>@CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；</xhtml:p><xhtml:p>@RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；</xhtml:p><xhtml:p>@RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；</xhtml:p><xhtml:p>@ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；</xhtml:p><xhtml:p>@ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；</xhtml:p><xhtml:p>@ExceptionHandler：注解式声明异常处理器；</xhtml:p><xhtml:p>@PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定，从而支持RESTful架构风格的URI；</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>Spring3.1使用新的HandlerMapping 和 HandlerAdapter来支持@Contoller和@RequestMapping注解处理器。</xhtml:p><xhtml:p>新的@Contoller和@RequestMapping注解支持类：处理器映射RequestMappingHandlerMapping</xhtml:p><xhtml:p>和处理器适配器RequestMappingHandlerAdapter组合来代替Spring2.5开始的处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter，提供更多的展点。</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>URL路径映射：使用URL映射请求到处理器的功能处理方法；</xhtml:p><xhtml:p>请求方法映射限定：如限定功能处理方法只处理GET请求；</xhtml:p><xhtml:p>请求参数映射限定：如限定只处理包含“abc”请求参数的请求；</xhtml:p><xhtml:p>请求头映射限定：如限定只处理“Accept=application/json”的请求。</xhtml:p><xhtml:p/><xhtml:p><xhtml:img xhtml:src="xap:attachments/2nq25adodo4a6d1mf6oncl8leq.png"/></xhtml:p></html><plain>Spring2.5引入注解式处理器支持，通过@Controller 和 @RequestMapping注解定义我们的处理器类。
并且提供了一组强大的注解：
需要通过处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter来开启支持@Controller 和 @RequestMapping注解的处理器。
@Controller：用于标识是处理器类；
@RequestMapping：请求到处理器功能方法的映射规则；
@RequestParam：请求参数到处理器功能处理方法的方法参数上的绑定；
@ModelAttribute：请求参数到命令对象的绑定；
@SessionAttributes：用于声明session级别存储的属性，放置在处理器类上，通常列出模型属性（如@ModelAttribute）对应的名称，则这些属性会透明的保存到session中；
@InitBinder：自定义数据绑定注册支持，用于将请求参数转换到命令对象属性的对应类型；


Spring3.0引入RESTful架构风格支持(通过@PathVariable注解和一些其他特性支持),且又引入了更多的注解支持：
@CookieValue：cookie数据到处理器功能处理方法的方法参数上的绑定；
@RequestHeader：请求头（header）数据到处理器功能处理方法的方法参数上的绑定；
@RequestBody：请求的body体的绑定（通过HttpMessageConverter进行类型转换）；
@ResponseBody：处理器功能处理方法的返回值作为响应体（通过HttpMessageConverter进行类型转换）；
@ResponseStatus：定义处理器功能处理方法/异常处理器返回的状态码和原因；
@ExceptionHandler：注解式声明异常处理器；
@PathVariable：请求URI中的模板变量部分到处理器功能处理方法的方法参数上的绑定，从而支持RESTful架构风格的URI；


Spring3.1使用新的HandlerMapping 和 HandlerAdapter来支持@Contoller和@RequestMapping注解处理器。
新的@Contoller和@RequestMapping注解支持类：处理器映射RequestMappingHandlerMapping
和处理器适配器RequestMappingHandlerAdapter组合来代替Spring2.5开始的处理器映射DefaultAnnotationHandlerMapping和处理器适配器AnnotationMethodHandlerAdapter，提供更多的展点。


URL路径映射：使用URL映射请求到处理器的功能处理方法；
请求方法映射限定：如限定功能处理方法只处理GET请求；
请求参数映射限定：如限定只处理包含“abc”请求参数的请求；
请求头映射限定：如限定只处理“Accept=application/json”的请求。

</plain></notes><children><topics type="attached"><topic id="2caacvle9at86rh6rocqfdcgqb" timestamp="1392788883780"><title>1、header限定</title><children><topics type="attached"><topic id="0ehijggi0v0i0uqougt95dshi0" timestamp="1392788841288"><title>1、Media Type</title><notes><html><xhtml:p>媒体类型格式：type/subtype(;parameter)?</xhtml:p><xhtml:p>type主类型，任意的字符串，如text，如果是*号代表所有；</xhtml:p><xhtml:p>subtype 子类型，任意的字符串，如html，如果是*号代表所有；</xhtml:p><xhtml:p>parameter 可选，一些参数，如Accept请求头的q参数， Content-Type的 charset参数。</xhtml:p><xhtml:p/><xhtml:p>详见http://tools.ietf.org/html/rfc2616#section-3.7</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>text/html ： HTML格式           text/plain ：纯文本格式              text/xml ：XML格式</xhtml:p><xhtml:p>image/gif ：gif图片格式          image/jpeg ：jpg图片格式          image/png：png图片格式</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>application/x-www-form-urlencoded ： &lt;form encType=””&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）。</xhtml:p><xhtml:p>multipart/form-data ： 当你需要在表单中进行文件上传时，就需要使用该格式；</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>application/xhtml+xml ：XHTML格式               application/xml     ： XML数据格式 </xhtml:p><xhtml:p>application/atom+xml  ：Atom XML聚合格式    application/json    ： JSON数据格式</xhtml:p><xhtml:p>application/pdf       ：pdf格式                           application/msword  ： Word文档格式</xhtml:p><xhtml:p>application/octet-stream ： 二进制流数据（如常见的文件下载）</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>在如tomcat服务器的 “conf/web.xml”中指定了扩展名到媒体类型的映射，在此我们可以看到服务器支持的媒体类型</xhtml:p><xhtml:p/></html><plain>媒体类型格式：type/subtype(;parameter)?
type主类型，任意的字符串，如text，如果是*号代表所有；
subtype 子类型，任意的字符串，如html，如果是*号代表所有；
parameter 可选，一些参数，如Accept请求头的q参数， Content-Type的 charset参数。

详见http://tools.ietf.org/html/rfc2616#section-3.7


text/html ： HTML格式           text/plain ：纯文本格式              text/xml ：XML格式
image/gif ：gif图片格式          image/jpeg ：jpg图片格式          image/png：png图片格式
 
application/x-www-form-urlencoded ： &lt;form encType=””&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）。
multipart/form-data ： 当你需要在表单中进行文件上传时，就需要使用该格式；
 
application/xhtml+xml ：XHTML格式               application/xml     ： XML数据格式 
application/atom+xml  ：Atom XML聚合格式    application/json    ： JSON数据格式
application/pdf       ：pdf格式                           application/msword  ： Word文档格式
application/octet-stream ： 二进制流数据（如常见的文件下载）
 
在如tomcat服务器的 “conf/web.xml”中指定了扩展名到媒体类型的映射，在此我们可以看到服务器支持的媒体类型
</plain></notes></topic><topic id="6bacp3i0himbual4apems4e7ea" timestamp="1392788845592"><title>2、Content-Type：内容类型</title><notes><html><xhtml:p>@RequestMapping(value = "/ContentType", method = RequestMethod.POST,  <xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">headers = "Content-Type=application/x-www-form-urlencoded"</xhtml:span>)  </xhtml:p><xhtml:p>    public String request1(HttpServletRequest request) throws IOException {  </xhtml:p><xhtml:p>        //①得到请求的内容区数据的类型  </xhtml:p><xhtml:p>        String contentType = request.getContentType();   </xhtml:p><xhtml:p>        System.out.println("========ContentType:" + contentType);  </xhtml:p><xhtml:p>        //②得到请求的内容区数据的编码方式，<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">如果请求中没有指定则为null  </xhtml:span></xhtml:p><xhtml:p>        //注意，我们的CharacterEncodingFilter这个过滤器设置了编码(UTF-8)  </xhtml:p><xhtml:p>        //<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">编码只能被指定一次，即如果客户端设置了编码，则过滤器不会再设置</xhtml:span>  </xhtml:p><xhtml:p>        String characterEncoding = request.getCharacterEncoding();  </xhtml:p><xhtml:p>        System.out.println("========CharacterEncoding:" + characterEncoding);  </xhtml:p><xhtml:p>          </xhtml:p><xhtml:p>        //③表示请求的内容区数据为form表单提交的参数，此时我们可以通过request.getParameter得到数据（key=value）  </xhtml:p><xhtml:p>        System.out.println(request.getParameter("realname"));  </xhtml:p><xhtml:p>        System.out.println(request.getParameter("username"));  </xhtml:p><xhtml:p>        return "success";  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p/><xhtml:p>request.getContentLength()：可以得到请求头的内容区数据的长度</xhtml:p><xhtml:p>request.getCharacterEncoding()：如“Content-Type:application/json;charset=GBK”,则得到的编码为“GBK”，否则如果你设置过滤器（CharacterEncodingFilter）则得到它设置的编码，否则返回null</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>//请求的地址  </xhtml:p><xhtml:p>String url = "http://localhost:9080/springmvc-chapter6/request/ContentType";  </xhtml:p><xhtml:p>//①创建Http Request(内部使用HttpURLConnection)  </xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">ClientHttpRequest request = new SimpleClientHttpRequestFactory().createRequest(new URI(url), HttpMethod.POST);  </xhtml:span></xhtml:p><xhtml:p>//②设置请求头的内容类型头和内容编码（GBK）  </xhtml:p><xhtml:p>request.getHeaders().set("Content-Type", "application/json;charset=gbk");  </xhtml:p><xhtml:p>//③以GBK编码写出请求内容体  </xhtml:p><xhtml:p>String jsonData = "{\"username\":\"zhang\", \"password\":\"123\"}";  </xhtml:p><xhtml:p>request.getBody().write(jsonData.getBytes("gbk"));  </xhtml:p><xhtml:p>//④发送请求并得到响应  </xhtml:p><xhtml:p>ClientHttpResponse response = request.execute();  </xhtml:p><xhtml:p>System.out.println(response.getStatusCode());  </xhtml:p><xhtml:p/><xhtml:p/><xhtml:p/></html><plain>@RequestMapping(value = "/ContentType", method = RequestMethod.POST,  headers = "Content-Type=application/x-www-form-urlencoded")  
    public String request1(HttpServletRequest request) throws IOException {  
        //①得到请求的内容区数据的类型  
        String contentType = request.getContentType();   
        System.out.println("========ContentType:" + contentType);  
        //②得到请求的内容区数据的编码方式，如果请求中没有指定则为null  
        //注意，我们的CharacterEncodingFilter这个过滤器设置了编码(UTF-8)  
        //编码只能被指定一次，即如果客户端设置了编码，则过滤器不会再设置  
        String characterEncoding = request.getCharacterEncoding();  
        System.out.println("========CharacterEncoding:" + characterEncoding);  
          
        //③表示请求的内容区数据为form表单提交的参数，此时我们可以通过request.getParameter得到数据（key=value）  
        System.out.println(request.getParameter("realname"));  
        System.out.println(request.getParameter("username"));  
        return "success";  
    }  

request.getContentLength()：可以得到请求头的内容区数据的长度
request.getCharacterEncoding()：如“Content-Type:application/json;charset=GBK”,则得到的编码为“GBK”，否则如果你设置过滤器（CharacterEncodingFilter）则得到它设置的编码，否则返回null


//请求的地址  
String url = "http://localhost:9080/springmvc-chapter6/request/ContentType";  
//①创建Http Request(内部使用HttpURLConnection)  
ClientHttpRequest request = new SimpleClientHttpRequestFactory().createRequest(new URI(url), HttpMethod.POST);  
//②设置请求头的内容类型头和内容编码（GBK）  
request.getHeaders().set("Content-Type", "application/json;charset=gbk");  
//③以GBK编码写出请求内容体  
String jsonData = "{\"username\":\"zhang\", \"password\":\"123\"}";  
request.getBody().write(jsonData.getBytes("gbk"));  
//④发送请求并得到响应  
ClientHttpResponse response = request.execute();  
System.out.println(response.getStatusCode());  


</plain></notes></topic><topic id="15ir4cmq3qvnkh0b4lr3tmd2rm" timestamp="1392788841279"><title>3、Accept</title><notes><html><xhtml:p>@RequestMapping(value = "/response/ContentType", headers = "<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">Accept=application/json</xhtml:span>")  </xhtml:p><xhtml:p>public void response2(HttpServletResponse response) throws IOException {  </xhtml:p><xhtml:p>    //①表示响应的内容区数据的媒体类型为json格式，且编码为utf-8(客户端应该以utf-8解码)  </xhtml:p><xhtml:p>    response.setContentType("application/json;charset=utf-8");  </xhtml:p><xhtml:p>    //②写出响应体内容  </xhtml:p><xhtml:p>    String jsonData = "{\"username\":\"zhang\", \"password\":\"123\"}";  </xhtml:p><xhtml:p>    response.getWriter().write(jsonData);  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>    //请求的地址  </xhtml:p><xhtml:p>    String url = "http://localhost:9080/springmvc-chapter6/response/ContentType";  </xhtml:p><xhtml:p>    //①创建Http Request(内部使用HttpURLConnection)  </xhtml:p><xhtml:p>    ClientHttpRequest request = new SimpleClientHttpRequestFactory().createRequest(new URI(url), HttpMethod.POST);  </xhtml:p><xhtml:p>    //②设置客户端可接受的媒体类型（即需要什么类型的响应体数据）  </xhtml:p><xhtml:p>    <xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">request.getHeaders().set("Accept", "application/json");</xhtml:span>          </xhtml:p><xhtml:p>    //③发送请求并得到响应  </xhtml:p><xhtml:p>    ClientHttpResponse response = request.execute();  </xhtml:p><xhtml:p>    //④得到响应体的编码方式  </xhtml:p><xhtml:p>    Charset charset = response.getHeaders().getContentType().getCharSet();          </xhtml:p><xhtml:p>    //⑤得到响应体的内容          </xhtml:p><xhtml:p>    InputStream is = response.getBody();  </xhtml:p><xhtml:p>    byte bytes[] = new byte[(int)response.getHeaders().getContentLength()];  </xhtml:p><xhtml:p>    is.read(bytes);  </xhtml:p><xhtml:p>    String jsonData = new String(bytes, charset);  </xhtml:p><xhtml:p>    System.out.println("charset : " + charset + ", json data : " + jsonData);  </xhtml:p><xhtml:p/><xhtml:p/></html><plain>@RequestMapping(value = "/response/ContentType", headers = "Accept=application/json")  
public void response2(HttpServletResponse response) throws IOException {  
    //①表示响应的内容区数据的媒体类型为json格式，且编码为utf-8(客户端应该以utf-8解码)  
    response.setContentType("application/json;charset=utf-8");  
    //②写出响应体内容  
    String jsonData = "{\"username\":\"zhang\", \"password\":\"123\"}";  
    response.getWriter().write(jsonData);  
}  


    //请求的地址  
    String url = "http://localhost:9080/springmvc-chapter6/response/ContentType";  
    //①创建Http Request(内部使用HttpURLConnection)  
    ClientHttpRequest request = new SimpleClientHttpRequestFactory().createRequest(new URI(url), HttpMethod.POST);  
    //②设置客户端可接受的媒体类型（即需要什么类型的响应体数据）  
    request.getHeaders().set("Accept", "application/json");          
    //③发送请求并得到响应  
    ClientHttpResponse response = request.execute();  
    //④得到响应体的编码方式  
    Charset charset = response.getHeaders().getContentType().getCharSet();          
    //⑤得到响应体的内容          
    InputStream is = response.getBody();  
    byte bytes[] = new byte[(int)response.getHeaders().getContentLength()];  
    is.read(bytes);  
    String jsonData = new String(bytes, charset);  
    System.out.println("charset : " + charset + ", json data : " + jsonData);  

</plain></notes></topic><topic id="48a4ocobu6qv7hf66ut4qc47fa" timestamp="1392788841271"><title>4、生产者、消费者请求限定</title><notes><html><xhtml:p>&lt;!--Spring3.1开始的注解 HandlerMapping --&gt;  </xhtml:p><xhtml:p>&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.<xhtml:span style-id="335j900ljhcq0bctb00o364cit">RequestMappingHandlerMapping</xhtml:span>"/&gt;   </xhtml:p><xhtml:p>&lt;!--Spring3.1开始的注解 HandlerAdapter --&gt;  </xhtml:p><xhtml:p>&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">RequestMappingHandlerAdapter</xhtml:span>"/&gt;  </xhtml:p><xhtml:p/><xhtml:p>@RequestMapping(value = "/consumes", consumes = {"application/json"})：此处使用consumes来指定功能处理方法能消费的媒体类型，其通过请求头的“Content-Type”来判断</xhtml:p><xhtml:p/><xhtml:p>@RequestMapping(value = "/produces", produces = "application/json")：表示将功能处理方法将生产json格式的数据，此时根据请求头中的Accept进行匹配，如请求头“Accept:application/json”时即可匹配</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>当你有如下Accept头：</xhtml:p><xhtml:p>①Accept：text/html,application/xml,application/json</xhtml:p><xhtml:p>      将按照如下顺序进行produces的匹配 ①text/html ②application/xml ③application/json</xhtml:p><xhtml:p>②Accept：application/xml;q=0.5,application/json;q=0.9,text/html</xhtml:p><xhtml:p>      将按照如下顺序进行produces的匹配 ①text/html ②application/json ③application/xml</xhtml:p><xhtml:p>      q参数为媒体类型的质量因子，越大则优先权越高(从0到1)</xhtml:p><xhtml:p>③Accept：*/*,text/*,text/html</xhtml:p><xhtml:p>      将按照如下顺序进行produces的匹配 ①text/html ②text/* ③*/*</xhtml:p><xhtml:p/><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">窄化时是覆盖 而 非继承</xhtml:span></xhtml:p><xhtml:p>如类级别的映射为 @RequestMapping(value="/narrow", produces="text/html")，方法级别的为@RequestMapping(produces="application/xml")，此时<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">方法级别的映射将覆盖类级别</xhtml:span>的</xhtml:p><xhtml:p/><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">组合使用是“或”的关系</xhtml:span></xhtml:p><xhtml:p>@RequestMapping(produces={"text/html", "application/json"}) ：将匹配“Accept:text/html”或“Accept:application/json”</xhtml:p><xhtml:p/><xhtml:p/></html><plain>&lt;!--Spring3.1开始的注解 HandlerMapping --&gt;  
&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;   
&lt;!--Spring3.1开始的注解 HandlerAdapter --&gt;  
&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;  

@RequestMapping(value = "/consumes", consumes = {"application/json"})：此处使用consumes来指定功能处理方法能消费的媒体类型，其通过请求头的“Content-Type”来判断

@RequestMapping(value = "/produces", produces = "application/json")：表示将功能处理方法将生产json格式的数据，此时根据请求头中的Accept进行匹配，如请求头“Accept:application/json”时即可匹配


当你有如下Accept头：
①Accept：text/html,application/xml,application/json
      将按照如下顺序进行produces的匹配 ①text/html ②application/xml ③application/json
②Accept：application/xml;q=0.5,application/json;q=0.9,text/html
      将按照如下顺序进行produces的匹配 ①text/html ②application/json ③application/xml
      q参数为媒体类型的质量因子，越大则优先权越高(从0到1)
③Accept：*/*,text/*,text/html
      将按照如下顺序进行produces的匹配 ①text/html ②text/* ③*/*

窄化时是覆盖 而 非继承
如类级别的映射为 @RequestMapping(value="/narrow", produces="text/html")，方法级别的为@RequestMapping(produces="application/xml")，此时方法级别的映射将覆盖类级别的

组合使用是“或”的关系
@RequestMapping(produces={"text/html", "application/json"}) ：将匹配“Accept:text/html”或“Accept:application/json”

</plain></notes></topic></topics></children></topic><topic id="6tug28meps18p1rjv7h6e3kv2f" timestamp="1392789641548"><title>2、功能处理方法支持的类型</title><children><topics type="attached"><topic id="18psprbo01r5a7lpe6087lljmf" timestamp="1392789067417"><title>1、ServletRequest/HttpServletRequest 和 ServletResponse/HttpServletResponse</title><notes><html><xhtml:p>public String requestOrResponse(ServletRequest servletRequest, HttpServletRequest httpServletRequest,</xhtml:p><xhtml:p>	ServletResponse servletResponse, HttpServletResponse httpServletResponse) {</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/><xhtml:p>public void readerOrWriteBody(Reader reader, Writer writer)  </xhtml:p><xhtml:p>        throws IOException {  </xhtml:p><xhtml:p>    writer.write("hello");  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p>reader：获取请求的内容区字符流，等价于request.getReader();</xhtml:p><xhtml:p>writer：获取相应的内容区字符流，等价于response.getWriter()。</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>InputStream/OutputStream 和 Reader/Writer<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">两组不能同时使用，只能使用其中的一组</xhtml:span></xhtml:p></html><plain>public String requestOrResponse(ServletRequest servletRequest, HttpServletRequest httpServletRequest,
	ServletResponse servletResponse, HttpServletResponse httpServletResponse) {
}

public void readerOrWriteBody(Reader reader, Writer writer)  
        throws IOException {  
    writer.write("hello");  
}  
reader：获取请求的内容区字符流，等价于request.getReader();
writer：获取相应的内容区字符流，等价于response.getWriter()。
 
InputStream/OutputStream 和 Reader/Writer两组不能同时使用，只能使用其中的一组</plain></notes></topic><topic id="40mhcl4p000ij6dg8ue8cd6i0d" timestamp="1392788990150"><title>2、InputStream/OutputStream 和 Reader/Writer</title><notes><html><xhtml:p>public void inputOrOutBody(InputStream requestBodyIn, OutputStream responseBodyOut) throws IOException {  </xhtml:p><xhtml:p>	responseBodyOut.write("success".getBytes());  </xhtml:p><xhtml:p>}  </xhtml:p></html><plain>public void inputOrOutBody(InputStream requestBodyIn, OutputStream responseBodyOut) throws IOException {  
	responseBodyOut.write("success".getBytes());  
}  </plain></notes></topic><topic id="7mf9281cbvi6d5p8c31fn0ev1c" timestamp="1392789233434"><title>3、WebRequest/NativeWebRequest</title><notes><html><xhtml:p>WebRequest是Spring Web MVC提供的统一请求访问接口，不仅仅可以访问请求相关数据（如参数区数据、请求头数据，但访问不到Cookie区数据），还可以访问会话和上下文中的数据；NativeWebRequest继承了WebRequest，并提供访问本地Servlet API的方法</xhtml:p><xhtml:p/><xhtml:p>public String webRequest(WebRequest webRequest, NativeWebRequest nativeWebRequest) {  </xhtml:p><xhtml:p>    System.out.println(webRequest.getParameter("test"));//①得到请求参数test的值  </xhtml:p><xhtml:p>    webRequest.setAttribute("name", "value", WebRequest.SCOPE_REQUEST);//②  </xhtml:p><xhtml:p>    System.out.println(webRequest.getAttribute("name", WebRequest.SCOPE_REQUEST));  </xhtml:p><xhtml:p>    HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);//③  </xhtml:p><xhtml:p>    HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);  </xhtml:p><xhtml:p>    return "success";  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p/><xhtml:p>① webRequest.getParameter：访问请求参数区的数据，可以通过getHeader()访问请求头数据</xhtml:p><xhtml:p>② webRequest.setAttribute/getAttribute：到指定的作用范围内取/放属性数据，Servlet定义的三个作用范围分别使用如下常量代表：</xhtml:p><xhtml:p>            SCOPE_REQUEST ：代表请求作用范围；</xhtml:p><xhtml:p>           SCOPE_SESSION ：代表会话作用范围；</xhtml:p><xhtml:p>           SCOPE_GLOBAL_SESSION ：代表全局会话作用范围，即ServletContext上下文作用范围</xhtml:p><xhtml:p>③ nativeWebRequest.getNativeRequest/nativeWebRequest.getNativeResponse：得到本地的Servlet API</xhtml:p></html><plain>WebRequest是Spring Web MVC提供的统一请求访问接口，不仅仅可以访问请求相关数据（如参数区数据、请求头数据，但访问不到Cookie区数据），还可以访问会话和上下文中的数据；NativeWebRequest继承了WebRequest，并提供访问本地Servlet API的方法

public String webRequest(WebRequest webRequest, NativeWebRequest nativeWebRequest) {  
    System.out.println(webRequest.getParameter("test"));//①得到请求参数test的值  
    webRequest.setAttribute("name", "value", WebRequest.SCOPE_REQUEST);//②  
    System.out.println(webRequest.getAttribute("name", WebRequest.SCOPE_REQUEST));  
    HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);//③  
    HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse.class);  
    return "success";  
}  

① webRequest.getParameter：访问请求参数区的数据，可以通过getHeader()访问请求头数据
② webRequest.setAttribute/getAttribute：到指定的作用范围内取/放属性数据，Servlet定义的三个作用范围分别使用如下常量代表：
            SCOPE_REQUEST ：代表请求作用范围；
           SCOPE_SESSION ：代表会话作用范围；
           SCOPE_GLOBAL_SESSION ：代表全局会话作用范围，即ServletContext上下文作用范围
③ nativeWebRequest.getNativeRequest/nativeWebRequest.getNativeResponse：得到本地的Servlet API</plain></notes></topic><topic id="5pigl0bfj0tp0r8l3m04gd62vu" timestamp="1392789308697"><title>4、HttpSession</title><notes><html><xhtml:p>此处的session永远不为null</xhtml:p><xhtml:p/><xhtml:p>注意：session访问不是线程安全的，如果需要线程安全，需要设置AnnotationMethodHandlerAdapter或RequestMappingHandlerAdapter的<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">synchronizeOnSession</xhtml:span>属性为true</xhtml:p><xhtml:p>即可线程安全的访问session</xhtml:p></html><plain>此处的session永远不为null

注意：session访问不是线程安全的，如果需要线程安全，需要设置AnnotationMethodHandlerAdapter或RequestMappingHandlerAdapter的synchronizeOnSession属性为true
即可线程安全的访问session</plain></notes></topic><topic id="3sg0gffdd3mfnhrnneeht4c8c3" timestamp="1392789478755"><title>5、Model、Map或ModelMap</title><notes><html><xhtml:p/><xhtml:p>@RequestMapping(value = "/model")  </xhtml:p><xhtml:p>public String createUser(Model model, Map model2, ModelMap model3) {  </xhtml:p><xhtml:p>    model.addAttribute("a", "a");  </xhtml:p><xhtml:p>    model2.put("b", "b");  </xhtml:p><xhtml:p>    model3.put("c", "c");  </xhtml:p><xhtml:p>    System.out.println(model == model2);  </xhtml:p><xhtml:p>    System.out.println(model2 == model3);  </xhtml:p><xhtml:p>    return "success";</xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p>虽然此处注入的是三个不同的类型（Model model, Map model2, ModelMap model3），但三者是同一个对象</xhtml:p><xhtml:p/><xhtml:p>AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter将使用BindingAwareModelMap作为模型对象的实现</xhtml:p><xhtml:p>即此处我们的形参（Model model, Map model2, ModelMap model3）都是同一个<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">BindingAwareModelMap</xhtml:span>实例</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>@RequestMapping(value = "/mergeModel")  </xhtml:p><xhtml:p>public ModelAndView mergeModel(Model model) {  </xhtml:p><xhtml:p>    model.addAttribute("a", "a");//①添加模型数据  </xhtml:p><xhtml:p>    ModelAndView mv = new ModelAndView("success");  </xhtml:p><xhtml:p>    mv.addObject("a", "update");//②在视图渲染之前更新③处同名模型数据  </xhtml:p><xhtml:p>    model.addAttribute("a", "new");//③修改①处同名模型数据  </xhtml:p><xhtml:p>    //视图页面的a将显示为"update" 而不是"new"  </xhtml:p><xhtml:p>    return mv;  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p>从代码中我们可以总结出功能处理方法的返回值中的模型数据（如ModelAndView）会 <xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">合并</xhtml:span> 功能处理方法形式参数中的模型数据（如Model）</xhtml:p><xhtml:p>但如果两者之间有同名的，<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">返回值中的模型数据会覆盖形式参数中的模型数据</xhtml:span></xhtml:p><xhtml:p/><xhtml:p/></html><plain>
@RequestMapping(value = "/model")  
public String createUser(Model model, Map model2, ModelMap model3) {  
    model.addAttribute("a", "a");  
    model2.put("b", "b");  
    model3.put("c", "c");  
    System.out.println(model == model2);  
    System.out.println(model2 == model3);  
    return "success";
}  
虽然此处注入的是三个不同的类型（Model model, Map model2, ModelMap model3），但三者是同一个对象

AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter将使用BindingAwareModelMap作为模型对象的实现
即此处我们的形参（Model model, Map model2, ModelMap model3）都是同一个BindingAwareModelMap实例


@RequestMapping(value = "/mergeModel")  
public ModelAndView mergeModel(Model model) {  
    model.addAttribute("a", "a");//①添加模型数据  
    ModelAndView mv = new ModelAndView("success");  
    mv.addObject("a", "update");//②在视图渲染之前更新③处同名模型数据  
    model.addAttribute("a", "new");//③修改①处同名模型数据  
    //视图页面的a将显示为"update" 而不是"new"  
    return mv;  
}  
从代码中我们可以总结出功能处理方法的返回值中的模型数据（如ModelAndView）会 合并 功能处理方法形式参数中的模型数据（如Model）
但如果两者之间有同名的，返回值中的模型数据会覆盖形式参数中的模型数据

</plain></notes></topic><topic id="22pj059otb9ledik7ihaf1tt36" timestamp="1392789481923"><title>6、Errors/BindingResult</title></topic><topic id="45v0gujrg5c61q8tq00intcjuu" timestamp="1392789614058"><title>7、其他</title><notes><html><xhtml:p>public String other(Locale locale, Principal principal)  </xhtml:p><xhtml:p>java.util.Locale：得到当前请求的本地化信息，默认等价于ServletRequest.getLocale()，如果配置LocaleResolver解析器则由它决定Locale</xhtml:p><xhtml:p>java.security.Principal：该主体对象包含了验证通过的用户信息，等价于HttpServletRequest.getUserPrincipal()</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>HttpEntity、UriComponentsBuilder、SessionStatus、RedirectAttributes等</xhtml:p></html><plain>public String other(Locale locale, Principal principal)  
java.util.Locale：得到当前请求的本地化信息，默认等价于ServletRequest.getLocale()，如果配置LocaleResolver解析器则由它决定Locale
java.security.Principal：该主体对象包含了验证通过的用户信息，等价于HttpServletRequest.getUserPrincipal()


HttpEntity、UriComponentsBuilder、SessionStatus、RedirectAttributes等</plain></notes></topic></topics></children><notes><html><xhtml:p><xhtml:img xhtml:src="xap:attachments/7djork04s6njhldquch0vovq01.jpg"/></xhtml:p></html><plain/></notes></topic><topic id="0nlko300dnq146vdllr72m5g3d" timestamp="1392792820413"><title>3、常用注释</title><children><topics type="attached"><topic id="1hhuq1hc3pl92vddpq4lit299q" timestamp="1392790082122"><title>1、RequestParam</title><notes><html><xhtml:p>@RequestParam用于将<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">请求参数区数据</xhtml:span>映射到功能处理方法的参数上</xhtml:p><xhtml:p/><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">编译时，如果不讲变量属性信息添加到class文件中，则还需要指定RequestParam的value属性值</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">defaultValue：默认值，表示如果请求中没有同名参数时的默认值，默认值可以是SpEL表达式，如“#{systemProperties['java.vm.version']}”</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">public String requestparam4(@RequestParam(value="role</xhtml:span><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">",required=false) String username) </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">表示请求中可以没有名字为role</xhtml:span><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">的参数，如果没有默认为null，此处需要注意如下几点：</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">     原子类型：必须有值，否则抛出异常，如果允许空值请使用包装类代替</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">     Boolean包装类型类型：默认Boolean.FALSE，其他引用类型默认为null</xhtml:span><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">如果请求参数类似于url?role=admin&amp;rule=user，则实际roleList参数入参的数据为“admin,user”，即多个数据之间使用“，”分割；我们应该使用如下方式来接收多个请求参数：</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">public String requestparam7(@RequestParam(value="role") String[] roleList)  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">public String requestparam8(@RequestParam(value="list") List&lt;String&gt; list) </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p/></html><plain>@RequestParam用于将请求参数区数据映射到功能处理方法的参数上

编译时，如果不讲变量属性信息添加到class文件中，则还需要指定RequestParam的value属性值

value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入
required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码
defaultValue：默认值，表示如果请求中没有同名参数时的默认值，默认值可以是SpEL表达式，如“#{systemProperties['java.vm.version']}”

public String requestparam4(@RequestParam(value="role",required=false) String username) 
表示请求中可以没有名字为role的参数，如果没有默认为null，此处需要注意如下几点：
     原子类型：必须有值，否则抛出异常，如果允许空值请使用包装类代替
     Boolean包装类型类型：默认Boolean.FALSE，其他引用类型默认为null

如果请求参数类似于url?role=admin&amp;rule=user，则实际roleList参数入参的数据为“admin,user”，即多个数据之间使用“，”分割；我们应该使用如下方式来接收多个请求参数：
public String requestparam7(@RequestParam(value="role") String[] roleList)  
public String requestparam8(@RequestParam(value="list") List&lt;String&gt; list) 

</plain></notes></topic><topic id="09k446ovc59ak3p74ra6uv1kep" timestamp="1392790130325"><title>2、PathVariable</title><notes><html><xhtml:p>@RequestMapping(value="/users/{userId}/topics/{topicId}")  </xhtml:p><xhtml:p>public String test(@PathVariable(value="userId") int userId, @PathVariable(value="topicId") int topicId)</xhtml:p><xhtml:p/><xhtml:p/></html><plain>@RequestMapping(value="/users/{userId}/topics/{topicId}")  
public String test(@PathVariable(value="userId") int userId, @PathVariable(value="topicId") int topicId)

</plain></notes></topic><topic id="51c07q51um5bi9ih0cu4maoofh" timestamp="1392790205296"><title>3、CookieValue</title><notes><html><xhtml:p>@CookieValue用于将请求的Cookie数据映射到功能处理方法的参数上</xhtml:p><xhtml:p>public String test1(@CookieValue(value="JSESSIONID", defaultValue="") String sessionId)</xhtml:p><xhtml:p>public String test2(@CookieValue(value="JSESSIONID", defaultValue="") Cookie sessionId) </xhtml:p><xhtml:p/><xhtml:p/></html><plain>@CookieValue用于将请求的Cookie数据映射到功能处理方法的参数上
public String test1(@CookieValue(value="JSESSIONID", defaultValue="") String sessionId)
public String test2(@CookieValue(value="JSESSIONID", defaultValue="") Cookie sessionId) 

</plain></notes></topic><topic id="28kbspqtpbl0d8h3gg90a5lco4" timestamp="1392790236263"><title>4、RequestHeader</title><notes><html><xhtml:p>@RequestHeader用于将请求的头信息区数据映射到功能处理方法的参数上</xhtml:p><xhtml:p/><xhtml:p>@RequestMapping(value="/header")  </xhtml:p><xhtml:p>public String test(@RequestHeader("User-Agent") String userAgent, @RequestHeader(value="Accept") String[] accepts)  </xhtml:p></html><plain>@RequestHeader用于将请求的头信息区数据映射到功能处理方法的参数上

@RequestMapping(value="/header")  
public String test(@RequestHeader("User-Agent") String userAgent, @RequestHeader(value="Accept") String[] accepts)  </plain></notes></topic><topic id="7f79kie27qs08pr3csq0farrcq" timestamp="1392792211543"><title>5、@ModelAttribute绑定请求参数到命令对象</title><notes><html><xhtml:p>@ModelAttribute具有如下三个作用：</xhtml:p><xhtml:p/><xhtml:p>①绑定请求参数到命令对象：</xhtml:p><xhtml:p>		放在功能处理方法的入参上时，用于将<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">多个请求参数绑定到一个命令对象</xhtml:span>，从而简化绑定流程，而且自动暴露为模型数据用于视图页面展示时使用；</xhtml:p><xhtml:p/><xhtml:p>②暴露表单引用对象为模型数据：</xhtml:p><xhtml:p>		放在处理器的一般方法（非功能处理方法）上时，是<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">为表单准备要展示的表单引用对象</xhtml:span>，如注册时需要选择的所在城市等，<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">而且在执行功能处理方法（@RequestMapping注解的方法）之前，自			动添加到模型对象中，用于视图页面展示时使用</xhtml:span>；</xhtml:p><xhtml:p>		@ModelAttribute("cityList")  </xhtml:p><xhtml:p>		public List&lt;String&gt; cityList() {  </xhtml:p><xhtml:p>    			return Arrays.asList("北京", "山东");  </xhtml:p><xhtml:p>		} </xhtml:p><xhtml:p>		<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">如上代码会在执行功能处理方法之前执行，并将其自动添加到模型对象中，在功能处理方法中调用Model 入参的containsAttribute("cityList")将会返回true</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769"/></xhtml:p><xhtml:p>③暴露@RequestMapping方法返回值为模型数据：</xhtml:p><xhtml:p>		放在功能处理方法的返回值上时，是暴露功能处理方法的返回值为模型数据，用于视图页面展示时使用。</xhtml:p><xhtml:p>		public @ModelAttribute("user2") UserModel test3(@ModelAttribute("user2") UserModel user)  </xhtml:p><xhtml:p>		可以看到返回值类型是命令对象类型，而且通过@ModelAttribute("user2")注解，此时会暴露返回值到模型数据（名字为user2）中供视图展示使用。</xhtml:p><xhtml:p>		<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">此时Spring Web MVC会根据RequestToViewNameTranslator进行逻辑视图名的翻译</xhtml:span></xhtml:p><xhtml:p>		@ModelAttribute注解的返回值会覆盖@RequestMapping注解方法中的@ModelAttribute注解的同名命令对象。</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p/><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">当URI模板变量和请求参数同名时，URI模板变量具有高优先权</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">@ModelAttribute("user")  //①  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">public UserModel getUser(@RequestParam(value="username", defaultValue="") String username) {  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">	UserModel user = new UserModel();  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">	user.setRealname("zhang");  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">	return user; </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">}   </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">@RequestMapping(value="/model1") //②  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">public String test1(@ModelAttribute("user") UserModel user, Model model)   </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">此处我们看到①和②有同名的命令对象，那Spring Web MVC内部如何处理的呢：</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">(1、首先执行@ModelAttribute注解的方法，准备视图展示时所需要的模型数据；@ModelAttribute注解方法形式参数规则和@RequestMapping规则一样，如可以有@RequestParam等；</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">(2、执行@RequestMapping注解方法，进行模型绑定时首先查找模型数据中是否含有同名对象，如果有直接使用，如果没有通过反射创建一个，因此②处的user将使用①处返回的命令对象。即②处的user等于①处的user。</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">(3、@ModelAttribute注解的返回值会覆盖@RequestMapping注解方法中的@ModelAttribute注解的同名命令对象。</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">匿名绑定命令参数</xhtml:span><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">public String test4(@ModelAttribute UserModel user, Model model)  	----&gt;userModel</xhtml:span><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p><xhtml:span style-id="303lbd7aacbp39guvfh1p75af9">public String test5(UserModel user, Model model)    							----&gt;userModel????</xhtml:span><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu"/></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">public @ModelAttribute List&lt;String&gt; test6()  					----&gt;stringList</xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="317fo16auntqs6ks54nlnf28gu">public @ModelAttribute List&lt;UserModel&gt; test7()   			----&gt;userModelList</xhtml:span></xhtml:p></html><plain>@ModelAttribute具有如下三个作用：

①绑定请求参数到命令对象：
		放在功能处理方法的入参上时，用于将多个请求参数绑定到一个命令对象，从而简化绑定流程，而且自动暴露为模型数据用于视图页面展示时使用；

②暴露表单引用对象为模型数据：
		放在处理器的一般方法（非功能处理方法）上时，是为表单准备要展示的表单引用对象，如注册时需要选择的所在城市等，而且在执行功能处理方法（@RequestMapping注解的方法）之前，自			动添加到模型对象中，用于视图页面展示时使用；
		@ModelAttribute("cityList")  
		public List&lt;String&gt; cityList() {  
    			return Arrays.asList("北京", "山东");  
		} 
		如上代码会在执行功能处理方法之前执行，并将其自动添加到模型对象中，在功能处理方法中调用Model 入参的containsAttribute("cityList")将会返回true

③暴露@RequestMapping方法返回值为模型数据：
		放在功能处理方法的返回值上时，是暴露功能处理方法的返回值为模型数据，用于视图页面展示时使用。
		public @ModelAttribute("user2") UserModel test3(@ModelAttribute("user2") UserModel user)  
		可以看到返回值类型是命令对象类型，而且通过@ModelAttribute("user2")注解，此时会暴露返回值到模型数据（名字为user2）中供视图展示使用。
		此时Spring Web MVC会根据RequestToViewNameTranslator进行逻辑视图名的翻译
		@ModelAttribute注解的返回值会覆盖@RequestMapping注解方法中的@ModelAttribute注解的同名命令对象。



当URI模板变量和请求参数同名时，URI模板变量具有高优先权

@ModelAttribute("user")  //①  
public UserModel getUser(@RequestParam(value="username", defaultValue="") String username) {  
	UserModel user = new UserModel();  
	user.setRealname("zhang");  
	return user; 
}   
@RequestMapping(value="/model1") //②  
public String test1(@ModelAttribute("user") UserModel user, Model model)   
此处我们看到①和②有同名的命令对象，那Spring Web MVC内部如何处理的呢：
(1、首先执行@ModelAttribute注解的方法，准备视图展示时所需要的模型数据；@ModelAttribute注解方法形式参数规则和@RequestMapping规则一样，如可以有@RequestParam等；
(2、执行@RequestMapping注解方法，进行模型绑定时首先查找模型数据中是否含有同名对象，如果有直接使用，如果没有通过反射创建一个，因此②处的user将使用①处返回的命令对象。即②处的user等于①处的user。
(3、@ModelAttribute注解的返回值会覆盖@RequestMapping注解方法中的@ModelAttribute注解的同名命令对象。

匿名绑定命令参数
public String test4(@ModelAttribute UserModel user, Model model)  	----&gt;userModel
public String test5(UserModel user, Model model)    							----&gt;userModel????

public @ModelAttribute List&lt;String&gt; test6()  					----&gt;stringList
public @ModelAttribute List&lt;UserModel&gt; test7()   			----&gt;userModelList</plain></notes></topic><topic id="5qq5080v7l8je8j57u1bh8cmm2" timestamp="1392792819517"><title>6、SessionAttributes</title><notes><html><xhtml:p>//1、在控制器<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">类头</xhtml:span>上添加@SessionAttributes注解  </xhtml:p><xhtml:p>@SessionAttributes(value = {"user"})    //①  </xhtml:p><xhtml:p>public class SessionAttributeController   </xhtml:p><xhtml:p>  </xhtml:p><xhtml:p>//2、@ModelAttribute注解的方法进行表单引用对象的创建  </xhtml:p><xhtml:p>@ModelAttribute("user")    //②  </xhtml:p><xhtml:p>public UserModel initUser()   </xhtml:p><xhtml:p>  </xhtml:p><xhtml:p>//3、@RequestMapping注解方法的@ModelAttribute注解的参数进行命令对象的绑定  </xhtml:p><xhtml:p>@RequestMapping("/session1")   //③  </xhtml:p><xhtml:p>public String session1(@ModelAttribute("user") UserModel user)  </xhtml:p><xhtml:p>  </xhtml:p><xhtml:p>//4、<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">通过SessionStatus的setComplete()方法清除@SessionAttributes指定的会话数据</xhtml:span>  </xhtml:p><xhtml:p>@RequestMapping("/session2")   //③  </xhtml:p><xhtml:p>public String session(@ModelAttribute("user") UserModel user, SessionStatus status) {  </xhtml:p><xhtml:p>    if(true) { //④  </xhtml:p><xhtml:p>        status.setComplete();  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>    return "success";  </xhtml:p><xhtml:p>} </xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>@SessionAttributes(value = {"user"}) 标识将模型数据中的名字为“user” 的对象存储到会话中（默认HttpSession），此处value指定将模型数据中的哪些数据（名字进行匹配）存储到会话中，此外还有一个types属性表示模型数据中的哪些类型的对象存储到会话范围内，<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">如果同时指定value和types属性则那些名字和类型都匹配的对象才能存储到会话范围内</xhtml:span>。</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>包含@SessionAttributes的执行流程如下所示：</xhtml:p><xhtml:p>① 首先根据@SessionAttributes注解信息查找会话内的对象放入到模型数据中；</xhtml:p><xhtml:p>② 执行@ModelAttribute注解的方法：<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">如果模型数据中包含同名的数据，则不执行@ModelAttribute注解方法进行准备表单引用数据，而是使用①步骤中的会话数据</xhtml:span>；如果模型数据中不包含同名的数据，执行@ModelAttribute注解的方法并将返回值添加到模型数据中；</xhtml:p><xhtml:p>③ 执行@RequestMapping方法，绑定@ModelAttribute注解的参数：查找模型数据中是否有@ModelAttribute注解的同名对象，如果有直接使用，否则通过反射创建一个；并将请求参数绑定到该命令对象；</xhtml:p><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">此处需要注意：如果使用@SessionAttributes注解控制器类之后，③步骤一定是从模型对象中取得同名的命令对象，如果模型数据中不存在将抛出HttpSessionRequiredException Expected session attribute ‘user’(Spring3.1) </xhtml:span><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">或 </xhtml:span><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">HttpSessionRequiredException Session attribute ‘user’ required - not found in session(Spring3.0)异常。</xhtml:span></xhtml:p><xhtml:p>④ 如果会话可以销毁了，如多步骤提交表单的最后一步，此时可以调用SessionStatus对象的setComplete()标识当前会话的@SessionAttributes指定的数据可以清理了，此时当@RequestMapping功能处理方法执行完毕会进行清理会话数据。</xhtml:p></html><plain>//1、在控制器类头上添加@SessionAttributes注解  
@SessionAttributes(value = {"user"})    //①  
public class SessionAttributeController   
  
//2、@ModelAttribute注解的方法进行表单引用对象的创建  
@ModelAttribute("user")    //②  
public UserModel initUser()   
  
//3、@RequestMapping注解方法的@ModelAttribute注解的参数进行命令对象的绑定  
@RequestMapping("/session1")   //③  
public String session1(@ModelAttribute("user") UserModel user)  
  
//4、通过SessionStatus的setComplete()方法清除@SessionAttributes指定的会话数据  
@RequestMapping("/session2")   //③  
public String session(@ModelAttribute("user") UserModel user, SessionStatus status) {  
    if(true) { //④  
        status.setComplete();  
    }  
    return "success";  
} 


@SessionAttributes(value = {"user"}) 标识将模型数据中的名字为“user” 的对象存储到会话中（默认HttpSession），此处value指定将模型数据中的哪些数据（名字进行匹配）存储到会话中，此外还有一个types属性表示模型数据中的哪些类型的对象存储到会话范围内，如果同时指定value和types属性则那些名字和类型都匹配的对象才能存储到会话范围内。


包含@SessionAttributes的执行流程如下所示：
① 首先根据@SessionAttributes注解信息查找会话内的对象放入到模型数据中；
② 执行@ModelAttribute注解的方法：如果模型数据中包含同名的数据，则不执行@ModelAttribute注解方法进行准备表单引用数据，而是使用①步骤中的会话数据；如果模型数据中不包含同名的数据，执行@ModelAttribute注解的方法并将返回值添加到模型数据中；
③ 执行@RequestMapping方法，绑定@ModelAttribute注解的参数：查找模型数据中是否有@ModelAttribute注解的同名对象，如果有直接使用，否则通过反射创建一个；并将请求参数绑定到该命令对象；
此处需要注意：如果使用@SessionAttributes注解控制器类之后，③步骤一定是从模型对象中取得同名的命令对象，如果模型数据中不存在将抛出HttpSessionRequiredException Expected session attribute ‘user’(Spring3.1) 或 HttpSessionRequiredException Session attribute ‘user’ required - not found in session(Spring3.0)异常。
④ 如果会话可以销毁了，如多步骤提交表单的最后一步，此时可以调用SessionStatus对象的setComplete()标识当前会话的@SessionAttributes指定的数据可以清理了，此时当@RequestMapping功能处理方法执行完毕会进行清理会话数据。</plain></notes></topic><topic id="21u46aocpps4f2ffopmj536paj" timestamp="1392792863500"><title>7、@Value绑定SpEL表示式</title><notes><html><xhtml:p>public String test(@Value("#{systemProperties['java.vm.version']}") String jvmVersion) </xhtml:p></html><plain>public String test(@Value("#{systemProperties['java.vm.version']}") String jvmVersion) </plain></notes></topic></topics></children></topic><topic id="6s5ousu3766ursm63l8ug0q26h" timestamp="1392798175939"><title>4、类型转换、验证及格式化</title><children><topics type="attached"><topic id="17lgi4193a2lsclmioifu948qc" timestamp="1392795800335"><title>1、数据类型转换</title><children><topics type="attached"><topic id="4jtpo9anpj72vcmbjof0ov6lqt" timestamp="1392795798083"><title>1、Spring3之前的PropertyEditor</title><children><topics type="attached"><topic id="5hufgivvvm4h0oka31mlodpbn5" timestamp="1392795798069"><title>1、使用WebDataBinder进行控制器级别注册PropertyEditor（控制器独享）</title><notes><html><xhtml:p>@InitBinder</xhtml:p><xhtml:p>//<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">此处的参数也可以是ServletRequestDataBinder类型</xhtml:span></xhtml:p><xhtml:p>public void initBinder(WebDataBinder binder) throws Exception {</xhtml:p><xhtml:p>	//注册自定义的属性编辑器</xhtml:p><xhtml:p>	//1、日期</xhtml:p><xhtml:p>	DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");</xhtml:p><xhtml:p>	CustomDateEditor dateEditor = new CustomDateEditor(df, true);</xhtml:p><xhtml:p>	//表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换</xhtml:p><xhtml:p>	binder.registerCustomEditor(Date.class, dateEditor);	</xhtml:p><xhtml:p>	//自定义的电话号码编辑器(和【4.16.1、数据类型转换】一样)</xhtml:p><xhtml:p>	binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());</xhtml:p><xhtml:p>}</xhtml:p><xhtml:p/></html><plain>@InitBinder
//此处的参数也可以是ServletRequestDataBinder类型
public void initBinder(WebDataBinder binder) throws Exception {
	//注册自定义的属性编辑器
	//1、日期
	DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
	CustomDateEditor dateEditor = new CustomDateEditor(df, true);
	//表示如果命令对象有Date类型的属性，将使用该属性编辑器进行类型转换
	binder.registerCustomEditor(Date.class, dateEditor);	
	//自定义的电话号码编辑器(和【4.16.1、数据类型转换】一样)
	binder.registerCustomEditor(PhoneNumberModel.class, new PhoneNumberEditor());
}
</plain></notes></topic><topic id="0hv81r7da8g3cfknc3kngv7jr7" timestamp="1392795798073"><title>2、使用WebBindingInitializer批量注册PropertyEditor</title><notes><html><xhtml:p>因为我们的注解式控制器是POJO，没有实现任何东西，因此无法注入WebBindingInitializer，此时我们需要把WebBindingInitializer注入到我们的RequestMappingHandlerAdapter或AnnotationMethodHandlerAdapter，这样对于所有的注解式控制器都是共享的。</xhtml:p><xhtml:p/><xhtml:p>&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;  </xhtml:p><xhtml:p>  &lt;property name="webBindingInitializer"&gt;  </xhtml:p><xhtml:p>    &lt;bean class="cn.javass.chapter7.web.controller.support.initializer.MyWebBindingInitializer"/&gt;  </xhtml:p><xhtml:p>  &lt;/property&gt;  </xhtml:p><xhtml:p>&lt;/bean&gt;   </xhtml:p></html><plain>因为我们的注解式控制器是POJO，没有实现任何东西，因此无法注入WebBindingInitializer，此时我们需要把WebBindingInitializer注入到我们的RequestMappingHandlerAdapter或AnnotationMethodHandlerAdapter，这样对于所有的注解式控制器都是共享的。

&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;  
  &lt;property name="webBindingInitializer"&gt;  
    &lt;bean class="cn.javass.chapter7.web.controller.support.initializer.MyWebBindingInitializer"/&gt;  
  &lt;/property&gt;  
&lt;/bean&gt;   </plain></notes></topic><topic id="4hncd23g7523l0ibmb1ecl2kom" timestamp="1392795798077"><title>3全局级别注册PropertyEditor（全局共享）</title><notes><html><xhtml:p>只需要将我们自定义的PropertyEditor放在和你的<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">模型类同包下</xhtml:span>即可，且你的Editor命名规则必须是“<xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">模型类名Editor</xhtml:span>”，这样Spring会自动使用标准JavaBean架构进行自动识别</xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/68qtfiak5jn84tp4ssdcbduc0q.png"/></xhtml:p></html><plain>只需要将我们自定义的PropertyEditor放在和你的模型类同包下即可，且你的Editor命名规则必须是“模型类名Editor”，这样Spring会自动使用标准JavaBean架构进行自动识别
</plain></notes></topic></topics></children></topic><topic id="5s31j0hq073kuattv0fa3mone3" timestamp="1392797053070"><title>2、Spring3开始的类型转换系统</title><notes><html><xhtml:p>Spring3引入了更加通用的类型转换系统，其定义了SPI接口（Converter等）和相应的运行时执行类型转换的API（ConversionService等），在Spring中它和PropertyEditor功能类似，可以替代PropertyEditor来转换外部Bean属性的值到Bean属性需要的类型。</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>该类型转换系统是Spring通用的，其定义在org.springframework.core.convert包中，不仅仅在Spring Web MVC场景下。目标是完全替换PropertyEditor，提供无状态、强类型且可以在任意类型之间转换的类型转换系统，可以用于任何需要的地方，如SpEL、数据绑定。</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>Converter SPI完成通用的类型转换逻辑，如java.util.Date&lt;----&gt;java.lang.Long或java.lang.String----&gt;PhoneNumberModel等。</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p/><xhtml:p/><xhtml:p/></html><plain>Spring3引入了更加通用的类型转换系统，其定义了SPI接口（Converter等）和相应的运行时执行类型转换的API（ConversionService等），在Spring中它和PropertyEditor功能类似，可以替代PropertyEditor来转换外部Bean属性的值到Bean属性需要的类型。
 
该类型转换系统是Spring通用的，其定义在org.springframework.core.convert包中，不仅仅在Spring Web MVC场景下。目标是完全替换PropertyEditor，提供无状态、强类型且可以在任意类型之间转换的类型转换系统，可以用于任何需要的地方，如SpEL、数据绑定。
 
Converter SPI完成通用的类型转换逻辑，如java.util.Date&lt;----&gt;java.lang.Long或java.lang.String----&gt;PhoneNumberModel等。




</plain></notes><children><topics type="attached"><topic id="3c5h5pdn13329luggnphi71mp7" timestamp="1392796752930"><title>1、架构</title><notes><html><xhtml:p>￼类型转换器</xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/445fevd6l8cpocgdv6v63al34n.png"/><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">public interface Converter&lt;S, T&gt; { //① S是源类型 T是目标类型  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    T convert(S source); //② 转换S类型的source到T目标类型的转换方法  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">} </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">public interface GenericConverter {  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    Set&lt;ConvertiblePair&gt; getConvertibleTypes();  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">}  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">package org.springframework.core.convert.converter;  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">public interface ConditionalGenericConverter extends GenericConverter {  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">}   </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">package org.springframework.core.convert.converter;  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">public interface ConverterFactory&lt;S, R&gt; {  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">}  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">类型转换器注册器、类型转换服务</xhtml:span></xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/67n93t14phnsh2dd3s2qo4k359.png"/><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">package org.springframework.core.convert.converter;  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">public interface </xhtml:span><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">ConverterRegistry</xhtml:span><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"> {  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void addConverter(Converter&lt;?, ?&gt; converter);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void addConverter(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType, Converter&lt;?, ?&gt; converter);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void addConverter(GenericConverter converter);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void addConverterFactory(ConverterFactory&lt;?, ?&gt; converterFactory);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void removeConvertible(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">} </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">package org.springframework.core.convert;  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">public interface ConversionService {  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">} </xhtml:span></xhtml:p><xhtml:p/></html><plain>类型转换器


public interface Converter&lt;S, T&gt; { //① S是源类型 T是目标类型  
    T convert(S source); //② 转换S类型的source到T目标类型的转换方法  
} 
public interface GenericConverter {  
    Set&lt;ConvertiblePair&gt; getConvertibleTypes();  
    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);  
}  
package org.springframework.core.convert.converter;  
public interface ConditionalGenericConverter extends GenericConverter {  
    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);  
}   
package org.springframework.core.convert.converter;  
public interface ConverterFactory&lt;S, R&gt; {  
    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);  
}  



类型转换器注册器、类型转换服务

package org.springframework.core.convert.converter;  
public interface ConverterRegistry {  
    void addConverter(Converter&lt;?, ?&gt; converter);  
    void addConverter(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType, Converter&lt;?, ?&gt; converter);  
    void addConverter(GenericConverter converter);  
    void addConverterFactory(ConverterFactory&lt;?, ?&gt; converterFactory);  
    void removeConvertible(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);  
} 
package org.springframework.core.convert;  
public interface ConversionService {  
    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);  
    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);  
    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);  
    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);  
} 
</plain></notes></topic><topic id="7k5r927jcjfbffmun0n53ka43m" timestamp="1392796842874"><title>2、Spring内建的类型转换器</title><notes><html><xhtml:p><xhtml:img xhtml:src="xap:attachments/6ngc4mq4ukq8qj8rhp95uhq9d1.png"/><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/3v68514aajfm9sr7oqboaine49.png"/><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/5pl33jbrlaif7c75vpdedt3mcg.png"/></xhtml:p></html><plain>

</plain></notes></topic><topic id="18gndgtf3bp8k02eg1e8fceimf" timestamp="1392796984921"><title>3、自定义类型转换器</title><notes><html><xhtml:p>public class StringToPhoneNumberConverter implements Converter&lt;String, PhoneNumberModel&gt; {  </xhtml:p><xhtml:p>    Pattern pattern = Pattern.compile("^(\\d{3,4})-(\\d{7,8})$");  </xhtml:p><xhtml:p>    @Override  </xhtml:p><xhtml:p>    public PhoneNumberModel convert(String source) {          </xhtml:p><xhtml:p>        if(!StringUtils.hasLength(source)) {  </xhtml:p><xhtml:p>            //①如果source为空 返回null  </xhtml:p><xhtml:p>            return null;  </xhtml:p><xhtml:p>        }  </xhtml:p><xhtml:p>        Matcher matcher = pattern.matcher(source);  </xhtml:p><xhtml:p>        if(matcher.matches()) {  </xhtml:p><xhtml:p>            //②如果匹配 进行转换  </xhtml:p><xhtml:p>            PhoneNumberModel phoneNumber = new PhoneNumberModel();  </xhtml:p><xhtml:p>            phoneNumber.setAreaCode(matcher.group(1));  </xhtml:p><xhtml:p>            phoneNumber.setPhoneNumber(matcher.group(2));  </xhtml:p><xhtml:p>            return phoneNumber;  </xhtml:p><xhtml:p>        } else {  </xhtml:p><xhtml:p>            //③如果不匹配 转换失败  </xhtml:p><xhtml:p>            throw new IllegalArgumentException(String.format("类型转换失败，需要格式[010-12345678]，但格式是[%s]", source));  </xhtml:p><xhtml:p>        }  </xhtml:p><xhtml:p>    }  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p/><xhtml:p>@Test  </xhtml:p><xhtml:p>public void testStringToPhoneNumberConvert() {  </xhtml:p><xhtml:p>    DefaultConversionService conversionService = new DefaultConversionService();  </xhtml:p><xhtml:p>    conversionService.addConverter(new StringToPhoneNumberConverter());  </xhtml:p><xhtml:p>      </xhtml:p><xhtml:p>    String phoneNumberStr = "010-12345678";  </xhtml:p><xhtml:p>    PhoneNumberModel phoneNumber = conversionService.convert(phoneNumberStr, PhoneNumberModel.class);  </xhtml:p><xhtml:p>          </xhtml:p><xhtml:p>    Assert.assertEquals("010", phoneNumber.getAreaCode());  </xhtml:p><xhtml:p>}   </xhtml:p><xhtml:p>@Test  </xhtml:p><xhtml:p>public void testOtherConvert() {  </xhtml:p><xhtml:p>    DefaultConversionService conversionService = new DefaultConversionService();  </xhtml:p><xhtml:p>      </xhtml:p><xhtml:p>    //"1"---&gt;true（字符串“1”可以转换为布尔值true）  </xhtml:p><xhtml:p>    Assert.assertEquals(Boolean.valueOf(true), conversionService.convert("1", Boolean.class));  </xhtml:p><xhtml:p>      </xhtml:p><xhtml:p>    //"1,2,3,4"---&gt;List（转换完毕的集合大小为4）  </xhtml:p><xhtml:p>    Assert.assertEquals(4, conversionService.convert("1,2,3,4", List.class).size());  </xhtml:p><xhtml:p>}   </xhtml:p><xhtml:p/></html><plain>public class StringToPhoneNumberConverter implements Converter&lt;String, PhoneNumberModel&gt; {  
    Pattern pattern = Pattern.compile("^(\\d{3,4})-(\\d{7,8})$");  
    @Override  
    public PhoneNumberModel convert(String source) {          
        if(!StringUtils.hasLength(source)) {  
            //①如果source为空 返回null  
            return null;  
        }  
        Matcher matcher = pattern.matcher(source);  
        if(matcher.matches()) {  
            //②如果匹配 进行转换  
            PhoneNumberModel phoneNumber = new PhoneNumberModel();  
            phoneNumber.setAreaCode(matcher.group(1));  
            phoneNumber.setPhoneNumber(matcher.group(2));  
            return phoneNumber;  
        } else {  
            //③如果不匹配 转换失败  
            throw new IllegalArgumentException(String.format("类型转换失败，需要格式[010-12345678]，但格式是[%s]", source));  
        }  
    }  
}  

@Test  
public void testStringToPhoneNumberConvert() {  
    DefaultConversionService conversionService = new DefaultConversionService();  
    conversionService.addConverter(new StringToPhoneNumberConverter());  
      
    String phoneNumberStr = "010-12345678";  
    PhoneNumberModel phoneNumber = conversionService.convert(phoneNumberStr, PhoneNumberModel.class);  
          
    Assert.assertEquals("010", phoneNumber.getAreaCode());  
}   
@Test  
public void testOtherConvert() {  
    DefaultConversionService conversionService = new DefaultConversionService();  
      
    //"1"---&gt;true（字符串“1”可以转换为布尔值true）  
    Assert.assertEquals(Boolean.valueOf(true), conversionService.convert("1", Boolean.class));  
      
    //"1,2,3,4"---&gt;List（转换完毕的集合大小为4）  
    Assert.assertEquals(4, conversionService.convert("1,2,3,4", List.class).size());  
}   
</plain></notes></topic><topic id="068ha7d89uk2o7ogtrku78k6r0" timestamp="1392797431720"><title>4、集成到SpringMVC</title><notes><html><xhtml:p>&lt;!-- ①注册ConversionService --&gt;  </xhtml:p><xhtml:p>&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt;  </xhtml:p><xhtml:p>    &lt;property name="converters"&gt;  </xhtml:p><xhtml:p>       &lt;list&gt;  </xhtml:p><xhtml:p>            &lt;bean class="cn.javass.chapter7.web.controller.support.converter.StringToPhoneNumberConverter"/&gt;  </xhtml:p><xhtml:p>            &lt;bean class="cn.javass.chapter7.web.controller.support.converter.StringToDateConverter"&gt;  </xhtml:p><xhtml:p>                &lt;constructor-arg value="yyyy-MM-dd"/&gt;  </xhtml:p><xhtml:p>            &lt;/bean&gt;  </xhtml:p><xhtml:p>        &lt;/list&gt;  </xhtml:p><xhtml:p>    &lt;/property&gt;  </xhtml:p><xhtml:p>&lt;/bean&gt;   </xhtml:p><xhtml:p>FormattingConversionServiceFactoryBean：是FactoryBean实现，默认使用DefaultFormattingConversionService转换器服务实现；</xhtml:p><xhtml:p>converters：注册我们自定义的类型转换器，此处注册了String---&gt;PhoneNumberModel和String---&gt;Date的类型转换器。</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>&lt;!-- ②使用ConfigurableWebBindingInitializer注册conversionService --&gt;  </xhtml:p><xhtml:p>&lt;bean id="webBindingInitializer" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt;  </xhtml:p><xhtml:p>    &lt;property name="conversionService" ref="conversionService"/&gt;  </xhtml:p><xhtml:p>&lt;/bean&gt;   </xhtml:p><xhtml:p>此处我们通过ConfigurableWebBindingInitializer绑定初始化器进行ConversionService的注册</xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;  </xhtml:p><xhtml:p>	&lt;property name="webBindingInitializer" ref="webBindingInitializer"/&gt;  </xhtml:p><xhtml:p>&lt;/bean&gt; </xhtml:p><xhtml:p/><xhtml:p/><xhtml:p><xhtml:span style-id="6gfbflslb1ron2msrf5b67t769">同时使用PropertyEditor和ConversionService时，内部首先查找PropertyEditor进行类型转换，如果没有找到相应的PropertyEditor再通过ConversionService进行转换。</xhtml:span></xhtml:p></html><plain>&lt;!-- ①注册ConversionService --&gt;  
&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt;  
    &lt;property name="converters"&gt;  
       &lt;list&gt;  
            &lt;bean class="cn.javass.chapter7.web.controller.support.converter.StringToPhoneNumberConverter"/&gt;  
            &lt;bean class="cn.javass.chapter7.web.controller.support.converter.StringToDateConverter"&gt;  
                &lt;constructor-arg value="yyyy-MM-dd"/&gt;  
            &lt;/bean&gt;  
        &lt;/list&gt;  
    &lt;/property&gt;  
&lt;/bean&gt;   
FormattingConversionServiceFactoryBean：是FactoryBean实现，默认使用DefaultFormattingConversionService转换器服务实现；
converters：注册我们自定义的类型转换器，此处注册了String---&gt;PhoneNumberModel和String---&gt;Date的类型转换器。


&lt;!-- ②使用ConfigurableWebBindingInitializer注册conversionService --&gt;  
&lt;bean id="webBindingInitializer" class="org.springframework.web.bind.support.ConfigurableWebBindingInitializer"&gt;  
    &lt;property name="conversionService" ref="conversionService"/&gt;  
&lt;/bean&gt;   
此处我们通过ConfigurableWebBindingInitializer绑定初始化器进行ConversionService的注册


&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;  
	&lt;property name="webBindingInitializer" ref="webBindingInitializer"/&gt;  
&lt;/bean&gt; 


同时使用PropertyEditor和ConversionService时，内部首先查找PropertyEditor进行类型转换，如果没有找到相应的PropertyEditor再通过ConversionService进行转换。</plain></notes></topic></topics></children></topic></topics></children></topic><topic id="2mrcpiqsgg47rp1ucpphrm7jb2" timestamp="1392798004320"><title>2、数据格式化</title><notes><html><xhtml:p>Spring3引入了格式化转换器（Formatter SPI） 和格式化服务API（FormattingConversionService）从而支持这种需求。在Spring中它和PropertyEditor功能类似，可以替代PropertyEditor来进行对象的解析和格式化，而且支持细粒度的字段级别的格式化/解析。</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>Formatter SPI核心是完成解析和格式化转换逻辑，在如Web应用/客户端项目中，需要解析、打印/展示本地化的对象值时使用，如根据Locale信息将java.util.Date----&gt;java.lang.String打印/展示、java.lang.String----&gt;java.util.Date等。</xhtml:p><xhtml:p> </xhtml:p><xhtml:p>该格式化转换系统是Spring通用的，其定义在org.springframework.format包中，不仅仅在Spring Web MVC场景下。</xhtml:p></html><plain>Spring3引入了格式化转换器（Formatter SPI） 和格式化服务API（FormattingConversionService）从而支持这种需求。在Spring中它和PropertyEditor功能类似，可以替代PropertyEditor来进行对象的解析和格式化，而且支持细粒度的字段级别的格式化/解析。
 
Formatter SPI核心是完成解析和格式化转换逻辑，在如Web应用/客户端项目中，需要解析、打印/展示本地化的对象值时使用，如根据Locale信息将java.util.Date----&gt;java.lang.String打印/展示、java.lang.String----&gt;java.util.Date等。
 
该格式化转换系统是Spring通用的，其定义在org.springframework.format包中，不仅仅在Spring Web MVC场景下。</plain></notes><children><topics type="attached"><topic id="129taer68uops2ptnbf849n42v" timestamp="1392798002193"><title>1、架构</title><notes><html><xhtml:p>格式化转换器</xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/2teghnuoa76314cav7ld1lrugj.png"/></xhtml:p><xhtml:p/><xhtml:p>package org.springframework.format;  </xhtml:p><xhtml:p>public interface Parser&lt;T&gt; {  </xhtml:p><xhtml:p>    T parse(String text, Locale locale) throws ParseException;  </xhtml:p><xhtml:p>} </xhtml:p><xhtml:p/><xhtml:p>package org.springframework.format;  </xhtml:p><xhtml:p>public interface Printer&lt;T&gt; {  </xhtml:p><xhtml:p>    String print(T object, Locale locale);   </xhtml:p><xhtml:p>} </xhtml:p><xhtml:p/><xhtml:p>package org.springframework.format;  </xhtml:p><xhtml:p>public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p/><xhtml:p>package org.springframework.format;  </xhtml:p><xhtml:p>public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; {//①可以识别的注解类型  </xhtml:p><xhtml:p>    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();//②可以被A注解类型注解的字段类型集合  </xhtml:p><xhtml:p>    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);//③根据A注解类型和fieldType类型获取Printer  </xhtml:p><xhtml:p>    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);//④根据A注解类型和fieldType类型获取Parser  </xhtml:p><xhtml:p>}  </xhtml:p><xhtml:p/><xhtml:p/><xhtml:p>格式化转换器注册器、格式化服务</xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/7fl5v860caoij8udbfen96boc5.png"/><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">package org.springframework.format;  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">public interface FormatterRegistry extends ConverterRegistry {  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    //①添加格式化转换器（Spring3.1 新增API）  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void addFormatter(Formatter&lt;?&gt; formatter);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    //②为指定的字段类型添加格式化转换器  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    //③为指定的字段类型添加Printer和Parser  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    //④添加注解驱动的字段格式化工厂AnnotationFormatterFactory  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">    void addFormatterForFieldAnnotation(AnnotationFormatterFactory&lt;? extends Annotation&gt; annotationFormatterFactory);  </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">} </xhtml:span></xhtml:p><xhtml:p><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq">FormattingConversionService</xhtml:span></xhtml:p><xhtml:p><xhtml:img xhtml:src="xap:attachments/4kptlc9lfk5rc12mln1u8kqj1i.jpg"/><xhtml:span style-id="7vb6ov8jbb09qejv3n8ee635eq"/></xhtml:p><xhtml:p/><xhtml:p/></html><plain>格式化转换器


package org.springframework.format;  
public interface Parser&lt;T&gt; {  
    T parse(String text, Locale locale) throws ParseException;  
} 

package org.springframework.format;  
public interface Printer&lt;T&gt; {  
    String print(T object, Locale locale);   
} 

package org.springframework.format;  
public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {  
}  

package org.springframework.format;  
public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; {//①可以识别的注解类型  
    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();//②可以被A注解类型注解的字段类型集合  
    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);//③根据A注解类型和fieldType类型获取Printer  
    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);//④根据A注解类型和fieldType类型获取Parser  
}  


格式化转换器注册器、格式化服务

package org.springframework.format;  
public interface FormatterRegistry extends ConverterRegistry {  
    //①添加格式化转换器（Spring3.1 新增API）  
    void addFormatter(Formatter&lt;?&gt; formatter);  
    //②为指定的字段类型添加格式化转换器  
    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);  
    //③为指定的字段类型添加Printer和Parser  
    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);  
    //④添加注解驱动的字段格式化工厂AnnotationFormatterFactory  
    void addFormatterForFieldAnnotation(AnnotationFormatterFactory&lt;? extends Annotation&gt; annotationFormatterFactory);  
} 
FormattingConversionService


</plain></notes></topic><topic id="2pu4s2ubs1a3tk16hvbe7suvad" timestamp="1392798068515"><title>2、Spring内建格式化转换器</title><notes><html><xhtml:p><xhtml:img xhtml:src="xap:attachments/3en6hk9059q4smto6edg8kllpl.png"/></xhtml:p></html><plain/></notes></topic></topics></children></topic><topic id="5i2vs1sd5ncnfalup8avc6clfg" timestamp="1392798142069"><title>3、自定义类型转换器</title></topic><topic id="0g4crv62seq3ddr1n7vbk0bh16" timestamp="1392798175923"><title>子主题 4</title></topic></topics></children><notes><html><xhtml:p><xhtml:img xhtml:src="xap:attachments/069vrdnq594cl57r1or6l0h9jm.png"/></xhtml:p></html><plain/></notes></topic></topics></children></topic></topics></children></topic></topics></children></topic><title>画布 1</title><relationships><relationship end1="3fjv9qa31keanmlr329urk13io" end2="58qsk7mkhrlcofkve4lohl5ghh" id="0v1kv3j040v8r49jdanbielgqn" timestamp="1392795471591"><control-points><control-point index="0"><position svg:x="275" svg:y="-45"/></control-point><control-point index="1"><position svg:x="233" svg:y="48"/></control-point></control-points></relationship></relationships></sheet></xmap-revision-content>